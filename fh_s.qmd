# Area-level estimation: Fay-Herriot model

## Introduction

In this section, we will present a whole estimation procedure of the standard area-level model introduced by [@Fay1979] in R. As with the disclaimer in the preceding section, this practical manual is not intended to serve as a theoretical introduction to area-level models. Instead, it offers a set of straightforward and practical R scripts, accompanied by clear explanations, to demonstrate how these tasks can be carried out in R. For a theoretical foundation please refer to [@Fay1979] and [@RaoMolina2015]. In addition to theoretical information, the vignette "A framework for producing small area estimates based on area-level models in R" of the R package emdi ([@Harmening2023]) provides further code examples for the FH model.

In this chapter, we will describe how to run the univariate (standard) Fay-Herriot (FH) using simulated income data from Spain. The estimation procedure is explained step by step.

Step 1: Data preparation. Compute the direct estimates and their corresponding variances on the area-level and eventually perform variance smoothing. Aggregate the available auxiliary variables to the same area level and combine both input data.

Step 2: Model selection. Select the aggregated auxiliary variables at the area level for the FH model using a stepwise selection based on information criteria like the Akaike, Bayesian or Kullback information criteria.

Step 3: Model estimation of FH point estimates and their mean squared error (MSE) estimates as uncertainty measure. Eventually apply a transformation.

Step 4: Assessment of the estimated model. Check the FH model assumptions, including linearity, normality of predicted area effects and standardized model residuals. When violations of the model assumptions are detected, the application of a transformation might help. Repeat Step 3 including a transformation and check again the model assumptions.

Step 5: Comparison of the FH results with the direct estimates.

Step 6: Benchmark the FH point estimates for consistency with higher results.

Step 7: Preparation of the results. Create tables and maps of results.

Step 8: Saving the results. One option is to export the results to known formats like Excel or OpenDocument Spreadsheets.

We will show below the use of the `fh()` function from the R package emdi [@Harmening2023] which computes the EBLUPs and their MSE estimates of the standard
FH model and several extensions of it, among others it allows for the application of transformations. The function call is:

`fh(fixed, vardir, combined_data, domains = NULL, method = "reml", interval = NULL,   k = 1.345, mult_constant = 1, transformation = "no", backtransformation = NULL,   eff_smpsize = NULL, correlation = "no", corMatrix = NULL, Ci = NULL, tol = 1e-04,   maxit = 100, MSE = FALSE, mse_type = "analytical", B = c(50, 0), seed = 123)`

## Data and preparation

### Load required libraries

First of all, load the required R libraries. The code automatically installs the packages that are not yet installed and loads them. If you need further packages, please add them to the list of `p_load` which contains the packages required to the run the codes.

```{r libraries, message = FALSE, warning = FALSE}
if (sum(installed.packages()[,1] %in% "pacman") != 1){
  
  install.packages("pacman")
  
}

pacman::p_load(sae, survey, spdep, emdi, data.table, MASS, caret, dplyr, sf)

```

### Load the dataset
Usually, SAE combines multiple data sources: a survey data set and a census or administrative/register dataset. For the estimation of area-level models, we need area-level aggregates of the same area-level (e.g. NUTS3) of both datasets. The target variable (typically household welfare/income for poverty mapping) is available in the survey but not in the census data.

In this example, we use a synthetic data set adapted from R package `sae` called `incomedata`. The original data contains information for $n = 17,119$ fictitious individuals residing across $D = 52$ Spanish provinces. The variables include the name of the province of residence (`provlab`), province code (`prov`), as well as several correlates of income.

For this tutorial, we use a random 10% sample of the `incomedata` to estimate the poverty rates. For the univariate case, we use the income variable from 2012.


```{r load_data, message = FALSE, warning = FALSE}
income_dt <- readRDS("data/incomedata_sample.RDS")

glimpse(income_dt)
```

### Direct estimation

We will use the direct Horvitz-Thompons estimators that use the survey weights in `weight` variable. We calculate the sample sizes for each provinces and compute the direct estimates and their variances. We use the direct function of the emdi package here. Other options are e.g. the direct function of package sae or the svyby command of package survey. Then, we create a data.frame containing the direct estimate, the standard errors, the variances, the coefficient of variation and the design effects, that are needed for the arcsin transformation. The design effect is the ratio of the variance considering the sampling design to the variance estimated under simple random sampling. In some areas with a very small sample size, it may occur, that the individual data only consists of zeros and ones, resulting in a direct estimate of zero or one and a direct variance of zero. We set those areas to out-of-sample and for the final estimation results only the synthetic part of the FH model is used.

```{r direct, message = FALSE, warning = FALSE}
## calculate sample size for each province
sampsize_dt <- 
income_dt |>
  group_by(provlab) |>
  summarize(N = n())

## computation of direct estimates and their variances
direct_dt <- emdi::direct(y = "income2012",
                       smp_data = income_dt %>% as.data.table(),
                       smp_domains = "provlab",
                       weights = "weight",
                       threshold = unique(income_dt$povline2012),
                       var = TRUE)

## create dataframe
direct_dt <- 
       direct_dt$ind |>
       dplyr::select(Domain, Head_Count) |>
       rename(Direct = "Head_Count") |>
       merge(direct_dt$MSE |>
               dplyr::select(Domain, Head_Count) |>
               rename(vardir = "Head_Count"),
             by = "Domain") |>
       mutate(SD = sqrt(vardir)) |>
       mutate(CV = SD / Direct) |>
       merge(sampsize_dt |> 
               mutate(provlab = as.factor(provlab)), 
             by.x = "Domain", 
             by.y = "provlab") |>
      mutate(var_SRS = Direct * (1 - Direct) / N) |>
      mutate(deff = vardir / var_SRS) |>
      mutate(n_eff = N/deff)

## set zero variance to OOS
direct_dt <- direct_dt[complete.cases(direct_dt), ]

## have a look at sample sizes
summary(direct_dt$N)    
```

### Variance smoothing

A quick inspection of the preceding results will show some provinces contain low sample sizes which sometimes result in extreme value poverty rates and hence 0 variance. To avoid this, we will show you how to apply the variance smoothing method suggested by [@you2023application]. Please see the code and Roxygen comments below explaining the use of the `varsmoothie_king()` function which computes smoothed variances. In case, the arcsin transformation will be applied, the variance smoothing described here is not necessary, since the arcsin transformation works variance stabilizing itself. When applying the arcsin transformation, the direct variances are automatically set to 1/(4\*effective sampling size) when using the fh function of package emdi. The effective sample size equals the sample size of each area divided by the design effect. If the variance stabilizing effect is not enough, the design effect of a higher area level could also be used here (in this example the regions ac).

```{r varsmooting}

#' A function to perform variance smoothing
#' 
#' The variance smoothing function applies the methodology of (Hiridoglou and You, 2023)
#' which uses simply log linear regression to estimate direct variances for sample 
#' poverty rates which is useful for replacing poverty rates in areas with low sampling.
#' 
#' @param domain a vector of unique domain/target areas
#' @param direct_var the raw variances estimated from sample data e=
#' @param sampsize the sample size for each domain
#' 
#' @export

varsmoothie_king <- function(domain,
                             direct_var,
                             sampsize){

  dt <- data.table(Domain = domain,
                   var = direct_var,
                   n = sampsize)

  dt$log_n <- log(dt$n)
  dt$log_var <- log(dt$var)

  lm_model <- lm(formula = log_var ~ log_n,
                 data = dt[!(abs(dt$log_var) == Inf),])

  dt$pred_var <- predict(lm_model, newdata = dt)
  residual_var <-  summary(lm_model)$sigma^2
  dt$var_smooth <- exp(dt$pred_var) * exp(residual_var/2)

  return(dt[, c("Domain", "var_smooth"), with = F])

}


```

OK, the goal now is to use the above `varsmoothie_king()` function to add an additional column of smoothed variances into our `direct_dt` dataframe.

```{r}
var_smooth <- varsmoothie_king(domain = direct_dt$Domain,
                                 direct_var = direct_dt$vardir,
                                 sampsize = direct_dt$N)
direct_dt <- var_smooth %>% merge(direct_dt, by = "Domain")
```

### Auxiliary variable preparation

The FH model is a model of poverty rates at the target area level, hence the data format required for this exercise has the province as its unit of observation. This format has a few essential columns:

-   Variable for poverty rates

-   The set of candidate variables from which the most predicted of poverty rates will be selected

-   The target area variable identifier (i.e. in this case the province variable `prov` and `provlab`)

We prepare this dataset as follows:

```{r}

## create the candidate variables
candidate_vars <- colnames(income_dt)[!colnames(income_dt) %in% 
                                         c("provlab", "prov", 
                                           "income2012", "income2013", "income2014",
                                           "povline2012", "povline2013", "povline2014",
                                           "ac", "nat", "educ", "labor",
                                           "age")]
 
## change dummy of gen to 0 and 1
income_dt <- 
  income_dt %>%
  mutate(across(c(gen), ~ case_when(
    .x == 1 ~ 0,
    .x == 2 ~ 1,
    TRUE ~ NA_real_
  )))

### aggregating the unit-level data to the province level
prov_dt <- 
income_dt |>
  group_by(provlab) |>
  summarize(
    across(
      any_of(candidate_vars),
      ~ weighted.mean(x = ., w = weight, na.rm = TRUE),
      .names = "{.col}"
    )
  )

### combine the the dataframe containing the direct estimates and their variances with the province level data
comb_Data <- merge(direct_dt, prov_dt,
    by.x = "Domain", by.y = "provlab",
    all = TRUE)

```

## Model selection

### Model preparation

FH does not run if there is any missing value in the auxiliary variables, and therefore, any variable with missing value should be removed in advance.

```{r fh_arcsin, message = FALSE, warning = FALSE}
rowsNAcovariates <- rowSums(sapply(comb_Data[, c(candidate_vars)], is.na))
comb_Data <- comb_Data[rowsNAcovariates == 0, ]
```

### Build initial model

First we build the initial model, to which the variable selection is then applied.

In this example, we use the function fh to calculate the FH estimates. Because we want to estimate a ratio, we need to apply the arcsin transformation to guarantee that the results lie between 0 and 1. For that, we choose "arcsin" as transformation, and a bias-corrected backtransformation ("bc"). Additionally, the effective sample size, which equals the sample size of each area divided by the design effect, is needed for the arcsin transformation. For the variable selection, we set the MSE estimation to FALSE. In case, no transformation is desired, the transformation argument must be set to "no" and the inputs backtransformation and eff_smpsize are no longer needed.

### Check multicollinearity

With the help of the `step()` function of package emdi, we perform a variable selection based on the chosen variable selection criterion and directly get the model with fewer variables. The function `step_wrapper()` implemented below is a wrapper to the `step()` function and performs all the perfunctory cleaning necessary use the `step()` function. This includes dropping columns that are entirely missing (`NA`) and keep only complete cases/observations (for the model selection only the in-sample domains are used) and remove perfectly or near collinear variables and combinations.

```{r}

#' A function to perform stepwise variable selection based on selection criteria
#' 
#' @param dt data.frame, dataset containing the set of outcome and independent variables
#' @param xvars character vector, the set of x variables
#' @param y chr, the name of the y variable
#' @param cor_thresh double, a correlation threshold between 0 and 1
#' @param criteria character string, criteria that can be chosen are "AIC", "AICc", "AICb1", "AICb2", "BIC", "KIC", "KICc", "KICb1", or "KICb2". Defaults to "AIC". If transformation is set to "arcsin", only "AIC" and "BIC" can be chosen.
#' @param vardir character string, name of the variable containing the domain-specific sampling variances of the direct estimates that are included in dt
#' @param transformation character string, either "no" (default) or "arcsin".
#' @param eff_smpsize character string, name of the variable containing the effective sample sizes that are included in dt. Required argument when the arcsin transformation is chosen. Defaults to NULL.
#' 
#' @import data.table
#' @import caret
#' @importFrom emdi step fh

step_wrapper <- function(dt, xvars, y, cor_thresh = 0.95, criteria = "AIC",
                         vardir, transformation = "no", eff_smpsize) {
  
  dt <- as.data.table(dt)
 
  # Drop columns that are entirely NA
  dt <- dt[, which(unlist(lapply(dt, function(x) !all(is.na(x))))), with = FALSE]
  
  xvars <- xvars[xvars %in% colnames(dt)]
  
  # Keep only complete cases
  dt <- dt[complete.cases(dt),] 
  
  # Step 1: Remove aliased (perfectly collinear) variables
  model_formula <- as.formula(paste(y, "~", paste(xvars, collapse = " + ")))
  lm_model <- lm(model_formula, data = dt)
  aliased <- is.na(coef(lm_model))
  if (any(aliased)) {
    xvars <- names(aliased)[!aliased & names(aliased) != "(Intercept)"]
  }
  
  # Step 2: Remove near-linear combinations
  xmat <- as.matrix(dt[, ..xvars])
  combo_check <- tryCatch(findLinearCombos(xmat), error = function(e) NULL)
  if (!is.null(combo_check) && length(combo_check$remove) > 0) {
    xvars <- xvars[-combo_check$remove]
    xmat <- as.matrix(dt[, ..xvars])
  }
  
  # Step 3: Drop highly correlated variables
  cor_mat <- abs(cor(xmat))
  diag(cor_mat) <- 0
  while (any(cor_mat > cor_thresh, na.rm = TRUE)) {
    cor_pairs <- which(cor_mat == max(cor_mat, na.rm = TRUE), arr.ind = TRUE)[1, ]
    var1 <- colnames(cor_mat)[cor_pairs[1]]
    var2 <- colnames(cor_mat)[cor_pairs[2]]
    # Drop the variable with higher mean correlation
    drop_var <- if (mean(cor_mat[var1, ]) > mean(cor_mat[var2, ])) var1 else var2
    xvars <- setdiff(xvars, drop_var)
    xmat <- as.matrix(dt[, ..xvars])
    cor_mat <- abs(cor(xmat))
    diag(cor_mat) <- 0
  }
  
  # Step 4: Warn if still ill-conditioned
  cond_number <- kappa(xmat, exact = TRUE)
  if (cond_number > 1e10) {
    warning("Design matrix is ill-conditioned (condition number > 1e10). Consider reviewing variable selection.")
  }
  
  # Final model fit
  model_formula <- as.formula(paste(y, "~", paste(xvars, collapse = " + ")))
  
  # Stepwise selection
   if (transformation == "no"){
    stepwise_model <- emdi::step(fh(
  fixed = model_formula,
  vardir = vardir, combined_data = dt,
  method = "ml", transformation = "no", MSE = FALSE, B = c(0, 50)),
  criteria = criteria)
  }
  
  if (transformation == "arcsin"){
    stepwise_model <- emdi::step(fh(
  fixed = model_formula,
  vardir = vardir, combined_data = dt,
  method = "ml", transformation = "arcsin", backtransformation = "bc",
  eff_smpsize = eff_smpsize, MSE = FALSE),
  criteria = criteria)
  }
 
  
  return(stepwise_model)

}


```

We apply the function to select the variables.

```{r remove_multicol, message = FALSE, warning = FALSE}
fh_step <- step_wrapper(dt = comb_Data, 
                      xvars = candidate_vars,
                      y = "Direct",
                      cor_thresh = 0.8,
                      criteria = "AIC",
                      vardir = "vardir", 
                      transformation = "arcsin", 
                      eff_smpsize = "n_eff")

print(fh_step$fixed)
```

## Model estimation of FH point and their MSE estimates.

In this example, we use the function fh to calculate the FH estimates. Because we want to estimate a ratio, we need to apply the arcsin transformation to guarantee that the results lie between 0 and 1. For that, we choose "arcsin" as transformation, and a bias-corrected backtransformation ("bc"). Additionally, the effective sample size, which equals the sample size of each area divided by the design effect, is needed for the arcsin transformation. We set the MSE estimation to TRUE, the mse_type to boot (necessary for the type of transformation) and determine the number of bootstrap iterations. For practical applications, values larger than 200 are recommended. In case, no transformation is desired, the transformation argument must be set to "no" and the inputs backtransformation and eff_smpsize are no longer needed.

```{r model_est, message = FALSE, warning = FALSE}
fh_arcsin <- fh(
  fixed = Direct ~ age2 + age3 + age4 + age5 + educ1 + ntl + schyrs, #formula(fh_step$fixed),
  vardir = "vardir", combined_data = comb_Data, domains = "Domain",
  method = "ml", transformation = "arcsin", backtransformation = "bc",
  eff_smpsize = "n_eff", MSE = TRUE, mse_type = "boot", B = c(50, 0)) 

# Summary statistics of EBLUP estimates
summary(fh_arcsin$ind$FH)

# Summary statistics of MSE estimates
summary(fh_arcsin$MSE$FH)
```

## Assessment of the estimated model.

With the help of the `summary` method in the **emdi** package, we gain detailed insights into the data and model components. It includes information on the estimation methods used, the number of domains, the log-likelihood, and information criteria as proposed by Marhuenda et al. (2014). It also reports the adjusted R² from a standard linear model and the adjusted R² specific to FH models, as introduced by Lahiri and Suntornchost (2015). It also offers diagnostic measures to assess model assumptions regarding the standardized realized residuals and random effects. These include skewness and kurtosis (based on the *moments* package by Komsta and Novomestky, 2015), as well as Shapiro-Wilk test statistics and corresponding p-values to evaluate the normality of both error components.

```{r summary, message = FALSE, warning = FALSE}
summary(fh_arcsin)
```

We can see, that all domains have survey information and the variance of the random effects equals 7.643268e-05. All of the included auxiliary variables are significant on a 0.05 significance
level and their explanatory power is large with an adjusted R2
(for FH models) of around 0.74. The results of the Shapiro-Wilk-test indicate that normality is not rejected for both errors. 

### Diagnostic plots

We produce normal quantile-quantile (Q-Q) plots of the standardized realized residuals and random effects and plots of the kernel densities of the distribution of both error terms by the plots methods of emdi.

```{r plot, message = FALSE, warning = FALSE}
plot(fh_arcsin)
```
The plots show slight deviations of the distributions from normality, but together with the results of the Shapiro-Wilk-test, we do not reject the normality assumption.


## Comparison of the FH results with the direct estimates.

The FH estimates are expected to align closely with the direct estimates in domains with small direct MSEs and/or large sample sizes. Moreover, incorporating auxiliary information should enhance the precision of the direct estimates. We produce a scatter plot proposed by Brown et al. (2001) and a line plot. The fitted regression and the identity line of the scatter plot should not differ too much. The FH estimates should track the direct estimates within the line plot especially for domains with a large sample size/small MSE of the direct estimator. Furthermore, we compare the MSE and CV estimates for the direct and FH estimators using boxplots and ordered scatter plots (by setting the input arguments MSE and CV to TRUE).

Additionally, we compute a correlation coefficient of the direct estimates and the estimates of the regression-synthetic part of the FH model (Chandra et al., 2015) and a goodness of fit diagnostic (Brown et al., 2001).

```{r compare, message = FALSE, warning = FALSE}
compare_plot(fh_arcsin, MSE = TRUE, CV = TRUE)
compare(fh_arcsin)

```
The direct estimates are tracked by most of the FH estimates within the line plot. The precision of the direct estimates could be improved by the usage of the FH model in terms of MSEs and CVs.
The null hypothesis of the Brown test is not rejected and the correlation coefficient indicates a positive correlation (0.68) between the direct and FH estimates.

If the result of the model assessment is not satisfactory, the following should be checked again: Can the direct estimation including variance estimation be improved? Are there further auxiliary variables or must possible interaction effects be taken into account? Does a (different) transformation need to be used?

## Benchmark the FH point estimates for consistency with higher results.
Benchmarking is based on the principle that aggregated FH estimates should sum up to the estimates at a higher regional level.
```{r benchmarking, message = FALSE, warning = FALSE}
## quickly creating the poverty indicator
income_dt <- 
  income_dt |>
  mutate(poor2012 = ifelse(income2012 < povline2012, 1, 0))
## computing the benchmark value
benchmark_value <- weighted.mean(income_dt$poor2012, income_dt$weight)
## computing the share of population size in the total population size (Ni/N) per area
data("sizeprov")
comb_Data <- comb_Data |>
  left_join(sizeprov |>
  mutate(ratio_n = Nd/sum(Nd)), by = c("Domain" ="provlab"))


fh_bench <- benchmark(fh_arcsin,
                      benchmark = benchmark_value,
                      share = comb_Data$ratio_n, 
                      type = "ratio",
                      overwrite = TRUE)

```

## Preparation of the results.

Create one data frame that contains the direct and FH estimation results including MSE and CV results.
```{r res_prep, message = FALSE, warning = FALSE}
results <-as.data.frame(estimators(fh_arcsin, MSE = TRUE, CV = TRUE))
results
```

### Poverty map
With the help of geographical maps, the results can be presented in a user-friendly way and differences among the areas can be detected more easily. The domain identifiers in the data need to match to the respective identifiers of the shape file. Therefore, we create mapping table first. 
```{r fig-povmap}
## load the shapefile dataframe and convert it to an object of type sf which is a necessary input for the map_plot function
spain_dt <- readRDS("data/shapes/spainshape.RDS")
spain_dt <- sf::st_as_sf(spain_dt)

## Create a suitable mapping table

## Find the right order
domain_ord <- match(spain_dt$provlab, fh_arcsin$ind$Domain)

## Create the mapping table based on the order obtained above
map_tab <- data.frame(pop_data_id = fh_arcsin$ind$Domain[domain_ord],
                      shape_id = spain_dt$provlab)

## Create map
map_plot(object = fh_arcsin, MSE = TRUE, map_obj = spain_dt,
 map_dom_id = "provlab", map_tab = map_tab)

```

## Saving the results.

### Save workspace.

```{r save, message = FALSE, warning = FALSE}
write.excel(fh_arcsin,
  file = "fh_arcsin_output.xlsx",
  MSE = TRUE, CV = TRUE
)
```

### Export the model output and estimation results.

```{r saveexcel, message = FALSE, warning = FALSE}
write.excel(fh_arcsin,
  file = "fh_arcsin_output.xlsx",
  MSE = TRUE, CV = TRUE
)
```
