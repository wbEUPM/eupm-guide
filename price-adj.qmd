---
editor: source
editor_options: 
  chunk_output_type: console
---

```{r setup-price-adj, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE}
library(tidyverse)
```


# Price adjustment analysis

## Introduction

This guide follows the approaches proposed in [@amendola2025]. The 2019 Poland Household Budget Survey (HBS) is used to demonstrate the estimation of price deflators. Nevertheless, a consumption aggregate must be readily available in the HBS. If the HBS does not include a consumption aggregate, follow the steps described in [Appendix A](#appendix-a).


### Paasche Price Index Approach

We estimate the Paasche index using the HBS.  We start with the food Paasche and move to the food plus rent Paasche.

### Food Paasche Index

The food Paasche is defined as follow:

$$
P_h^{\text{food}} = \left( \sum_{j=1}^F w_j^h \left( \frac{p_j^0}{p_j^h} \right) \right)^{-1}
$$ {#eq-fpaasche}

where $w_j^h$ is the budget share for food item $j$ of household $h$, $F$ is the number of food items considered, and $p_j^h$ and $p_j^0$ are the corresponding market prices of item $j$ for household $h$ and for the reference household $0$, respectively.

In this section, we calculate two versions of the food Paasche index. The first is the food-only index, and the second is the food plus rent price index, which will be further explained in Section 3.2.2.

First, we first read the food item expenditure file and conduct clean by excluding items with missing or zero in values and quantities consumed.

Alforith:

Step 1. Compute the price for item j at hh level.
Step 2. Next, compute mean and median prices at the national level
Step 3. The same at regons level
Step 4. Compute the price for item j at hh level.


```{r paashe-1}
# food_expenditure_item <-
#   file.path("data", "price-adj", "food_expenditure_item.rds") %>% 
#   read_rds() 
# 
# # Step 1.
# # fe_step1 <-
#   food_expenditure_item %>%
#   select(
#     hh_id = hhid,
#     reg_id = woj,
#     # item_id = 
#       code,
#     foodq = cons_q,
#     value = cons,
#     quarter,
#     foodexp
#     ) %>% 
#   slice(1:1000) %>% 
# 
#   mutate(up = foodexp / foodq)  %>%
#   
#   group_by(code) %>%
#   mutate(
#     up0_mean = mean(up, na.rm = TRUE),
#     up0_p50 = median(up, na.rm=TRUE)
#     ) %>% 
#     
#   group_by(hh_id) %>% 
#   mutate(hh_budget = sum(foodexp)) %>% 
#     
#   group_by(hh_id, code ) %>% 
#   mutate(hh_item_budget = sum(foodexp)) %>% 
#   ungroup() %>% 
#   mutate(w_h = hh_item_budget / hh_budget)
```

```{r}
# ## Check the matching results and drop merge=2 if you expect. 
# food_expenditure_item <- food_expenditure_item %>%
#   filter(merge!=2) %>% 
#   select(-merge) 
# 
# food_expenditure_item <- mg(food_expenditure_item, up0_p50, key=c("code")) %>%
#   filter(merge!=2) %>% 
#   select(-merge)
# 
#       food_expenditure_item <- mg(food_expenditure_item, budget_shares_input, key=c("hhid")) %>%
#         filter(merge==3) %>% 
#         select(-merge) 

```

Calculate the budget shares used later to get the Paasche indexes and add the variable labels. The second variable is used in 3.2.2.

```{r}
#  # Generate budget shares of each food item for all 3 Paasche Indexes
# food_expenditure_item <- food_expenditure_item %>%
#   mutate(w_f_f = foodexp / expenditure_hh_f,
#          w_f_fr = foodexp / expenditure_hh_fr)
# 
# label(food_expenditure_item$w_f_f) <-   "Food item budget share of food paasche"
# label(food_expenditure_item$w_f_fr) <-  "Food item budget share of extended paasche (food + rent)"      
```

Check food shares add up to one.

```{r}
# check <- food_expenditure_item %>%
#   group_by(hhid) %>%
#   mutate(check_f = sum(w_f_f, na.rm = TRUE)) %>%
#   ungroup()
# summary(check$check_f)
# # Assert: Check if all check_f values round to 1 (equivalent to Stata `assert round(check_f) == 1`)
# if (!all(dplyr::near(check$check_f, 1, tol = 0.01))) {
#   stop("Not all values of check_f are approximately 1 within a tolerance of 0.01")
# }

```

To enhance the robustness of the denominator in the food Paasche index, we replace household-level \`up\` values with aggregated group-level estimates. Specifically, we calculate the mean (\`up_mean\`) and median (\`up_p50\`) of \`up\` at the \`(code, nuts2)\` level, where \`code\` denotes the food item and \`nuts2\`

```{r}
# Ensure 'up' is numeric
# food_expenditure_item <- food_expenditure_item %>%
#           mutate(up = as.numeric(up))
# 
# # Compute `up_mean` and `up_p50` at `(code, nuts2)` level
# up_stats <- food_expenditure_item %>%
#   group_by(code, nuts2) %>%
#   summarise(
#     up_mean = mean(up, na.rm = TRUE),
#     up_p50 = median(up, na.rm = TRUE),
#     .groups = "drop"
#   )        

```

Merge the aggregated prices just calculated back into the full dataset. Then, compute Equation (@eq-fpaasche) — the food Paasche index at the item level — for two versions: one based on food weights (\`\_f\`) and the other based on food plus rent weights (\`\_fr\`).

The variable \`check\` is created to verify the consistency of the prices. Specifically, we ensure that the mean of the sub-regional mean prices (\`up_mean\`) aligns with the national mean price (\`up0_mean\`). The check confirms that the sum of the weights equals one for each household, and that the prices are reasonable.

```{r}
# # Merge aggregated values back into the full dataset
# food_expenditure_item <- mg(food_expenditure_item, up_stats, key=c("code", "nuts2"))
# 
# food_expenditure_item <- food_expenditure_item %>%
#   mutate(
#     check = up0_mean / up_mean,  # Generate check variable
#     inve_paasche_food = w_f_f * (up0_mean / up_mean),
#     inve_paasche_food_fr = w_f_fr * (up0_mean / up_mean),
#     inve_paasche_food_p50 = w_f_f * (up0_p50 / up_p50),  # Now properly sized
#     inve_paasche_food_fr_p50 = w_f_fr * (up0_p50 / up_p50)  # Now properly sized
#   )
# 
# summary(food_expenditure_item$check)
# check2<- food_expenditure_item %>%
#   group_by(hhid) %>%
#   mutate(check2 = sum(w_f_f, na.rm = TRUE)) %>%
#   ungroup()
# # Assert: Check if all check2 values round to 1 (equivalent to Stata `assert round(check_f) == 1`)
# if (!all(dplyr::near(check2$check2, 1, tol = 0.01))) {
#   stop("Not all values of check2 are approximately 1 within a tolerance of 0.01")
# }            
# 
# food_expenditure_item <- food_expenditure_item %>%
#   select(-check)   

```

After computing the item-level Paasche indices and weights, we aggregate the results to the household level. This step involves summing the `inve_paasche_*` variables and the corresponding weights (`w_f_*`) across all food items within each household (`hhid`).

```{r}
# # Aggregate by household
# food_file <- food_expenditure_item %>%
#   group_by(hhid) %>%
#   summarise(
#     across(starts_with("inve_paasche"), ~ sum(., na.rm = TRUE)),  # Sum all inve_paasche* variables
#     across(starts_with("w_f_"), ~ sum(., na.rm = TRUE))  # Sum all w_f_* variables
#   )

# label(food_file$inve_paasche_food) <- 	"Food Paasche - HH level"
# label(food_file$inve_paasche_food_fr) <- 	"Food innput of extended paasche (food+rent)"
# label(food_file$inve_paasche_food_p50) <-     "Food Paasche (p50)- HH level"
# label(food_file$inve_paasche_food_fr_p50) <-   "Food input of extended paasche (p50, food+rent)"
# 
# summary(food_file[, c("inve_paasche_food","inve_paasche_food_fr", "inve_paasche_food_p50",
#                       "inve_paasche_food_fr_p50","w_f_f","w_f_fr")]) 
# 
# saveRDS(food_file, file.path(output, "food_file.rds"))

```

```{r}
# # Create a summary dataframe for display
# sum_tab <- food_file %>%
#   select(hhid, inve_paasche_food, inve_paasche_food_fr, inve_paasche_food_p50, inve_paasche_food_fr_p50) %>%
#   slice_head(n = 10)  # Show the first 10 rows
# kable(sum_tab, caption = "Summary of Household-Level Paasche Indices and Weights -showing only first two households")
```




# Appendix A. Data Preparation {#appendix-a .unnumbered}

## Consumption Aggregate {.unnumbered}

## Pre-cleaning raw data {.unnumbered}

Preparation of item code file including code description, measurement unit (kg, etc.) and description

First, we need to install the necessary packages, using the command “install”. In R software, the required packages are readxl and survey.

## Food {.unnumbered}

(Your explanation and R code go here)

## Non-food nondurable {.unnumbered}

(Your explanation and R code go here)

## Rent (Imputation) {.unnumbered}

If your HBS does not have self-reported rents for non-renters, you need to impute rents for non-renters. This section explains how the rent imputation.

(Your explanation and R code go here)

## Combining files and final check {.unnumbered}

(Your explanation and R code go here)