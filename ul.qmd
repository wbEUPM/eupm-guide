## Unit-Level Models

```{r, echo=FALSE, include=FALSE}

if (sum(installed.packages()[,1] %in% "pacman") != 1) {
  
  install.packages("pacman")
  
}

pacman::p_load(povmap, emdi, dplyr, tidyr,
               data.table, glmnet, glmmLasso,
               MASS, ggplot2, nlme, future,
               survey, flextable, officer,
               ggtext, gridExtra)


```

### Introduction

In this section, we will present an implementation of the Empirical Best Prediction (EBP) unit modelling approach in R based on World Bank's Small Area Estimation Guidelines, [@corral2022guidelines], as well as [@molina2010small] and [@rao2015small]. Similar to the disclaimer made in the previous section, this practical manual does not present a theoretical statistical primer on unit level poverty mapping. Rather, it presents a combination of practical and simple R scripts with appropriate explanations to expose the simplicity of performing these tasks in R to the user. The studies previously cited are excellent starting points for those interested in understanding the theoretical underpinnings for the code being presented here.

This chapter is subdivided as follows to show the whole game of the EBP linear mixed effect modelling approach:

(A) The Data: In this subsection, we present a brief checklist of data items needed for the unit level poverty mapping as well as present the specific data to be used in this chapter.

(B) Data Preparation: Here we present the process of transforming the data in (A) into what is needed for variable selection and then estimating a unit level poverty map

(C) Variable Selection: We present the LASSO methodology of the GLMNET, glmmLasso and hdm R packages as well as another implementation that uses the stepwise model

(D) EBP Unit Level Model Estimation: Having selected the set of variables, we proceed to use the povmap package's ebp function to estimate the poverty map.

(E) Post Estimation Diagnostics: We proceed to test model assumptions of the EBP linear mixed effects model and present functions within the povmap package for producing report ready figure and tables.

### The Data

The main idea of SAE is to combine multiple data sources. Typically, there is a survey data set and a census or administrative/register dataset both at an individual and/or household unit level. The target variable (typically household welfare/income for poverty mapping) is available in the survey but not in the census data. The goal of the exercise is to estimate welfare/income for each unit within the census or administrative register dataset by developing a model of welfare or income within the survey. It is important that the outcome variable has the same definition within the census or administrative dataset as the case maybe. It would be inappropriate to estimate household welfare/income within the survey and use the same model to predict income at the individual level of the census. Below is a brief checklist of data requirements needed for unit level poverty mapping with the povmap R package:

-   A unit level survey `data.frame` object with individual and household characteristics including the target area variable, outcome variable (welfare aggregates, income per capita etc)

-   A unit census/administrative register `dataframe` object with individual and household characteristics including the target area variable. The outcome variable is typically missing since the topic of this tutorial is estimating it.


For the purposes of this tutorial, we will use the European Union Statistics on Income and Living Conditions (EU-SILC) in Austria from 2006. Please see [@kreutzmann2019r] for the full description of the dataset

```{r}

### load the data

survey_dt <- eusilcA_smp

census_dt <- eusilcA_pop ## ignore the eqIncome variable that has been left in the eusilcA_pop dataset 

#### the survey dataset
head(survey_dt)

#### the census dataset
head(census_dt)


```

-   All target areas within the survey must be present within the census. The `emdi::ebp()` and `povmap::ebp()` function calls will result in an error message if values in the target area variable are missing within the survey, this includes `NA` values within the survey target area column that are not in the census' target area column.

```{r}

### counting the number of districts (i.e. target areas) within the survey that are not a subset of the census districts. 

x <- unique(survey_dt$district)[!unique(survey_dt$district) %in% unique(census_dt$district)]

length(x) ### there appear to be no areas as such


```

Other important data for poverty mapping include: 

- A shapefile : While a table of poverty rates would suffice, a picture is worth more than a 1000 words and as such `emdi` and `povmap` have functionality for converting the resulting estimates into a map using the `plot()` function within the `emdi` and `povmap` packages. It is essential that the target area variable in the census and survey (which by now should be consistent between the survey and census) should also match with the target area variable within the shapefile in order to use the `plot()` function within `emdi` or `povmap`. 

Once the following steps have been taken, the next stage is to prepare the set of variables for estimating a model of household welfare and predicting the consumption aggregates into the census.

### Data Preparation for unit level model

In this section, we describe a few common techniques for creating variables with strong correlations to the outcome variable. This includes creating: 

- variable interactions

- target area average variables

- dummy variables (at the lowest level of national representativeness, regional dummies, as well as other dummy variables to capture some non-linear relationships between the certain variables and the outcome variable)

First a little bit of housekeeping is in order: 

```{r}

### subset the set of candidate variables into a character vector

candidate_vars <- colnames(survey_dt)[!colnames(survey_dt) %in% 
                                        c("eqIncome", "weight", 
                                          "state", "district")]

### we have to ensure candidate variables are numbers (numeric or integer class)
##### the only variable that doesnt meet this criteria is the gender variable
survey_dt <- 
  survey_dt %>%
  mutate(gender = ifelse(gender == "female", 1, 0))

census_dt <- 
  census_dt %>%
  mutate(gender = ifelse(gender == "female", 1, 0))

```

#### Creating Variable Interactions

```{r}

### show the function we have used to automate interactions between variables

#' A function to interact a variables with a set of variables
#' 
#' @param dt a data.frame
#' @param interacter_var the variable to be interacted
#' @param var_list the set of variables to interact with
#' 
#' @export
#' 

create_interactions <- function(dt, interacter_var, var_list) {
  # Ensure dt is a data.table
  if (!"data.frame" %in% class(dt)) {
    dt <- as.data.table(dt)
  }
  
  # Check if interacter_var exists in the dataset
  if (!(interacter_var %in% names(dt))) {
    stop(paste(interacter_var, "not found in dataset"))
  }
  
  # Check if var_list contains valid variables that exist in the dataset
  if (any(!var_list %in% names(dt))) {
    stop("Some variables in var_list are not found in the dataset.")
  }
  
  # Create an empty data.table to store interactions
  int_dt <- data.frame(matrix(nrow = nrow(dt)))
  
  # Loop over var_list to create interaction terms
  for (var in var_list) {
    interaction_name <- paste0(var, "_X_", interacter_var)
    int_dt[[interaction_name]] <- dt[[var]] * dt[[interacter_var]]
  }
  
  int_dt <- int_dt[, -1]
  
  return(int_dt)
  
}

survey_dt <- 
  cbind(survey_dt, 
        create_interactions(dt = survey_dt,
                            interacter_var = "gender",
                            var_list = candidate_vars[!candidate_vars %in% "gender"]))

census_dt <- 
  cbind(census_dt, 
        create_interactions(dt = census_dt,
                            interacter_var = "gender",
                            var_list = candidate_vars[!candidate_vars %in% "gender"]))



```

#### Computing target area averages
It is often useful to compute target area averages to improve the explanation of intra-area variation in the dependent variable. Here is some code we have used in the past to do this: 

```{r}

#### compute target area level averages to include in the model
candidate_vars <- c(candidate_vars, 
                    colnames(survey_dt)[grepl("_X_", colnames(survey_dt))])

survey_dt <- 
  survey_dt %>%
  as.data.table() %>%
  .[, paste0(candidate_vars, "_targetmean") := 
      lapply(.SD, 
             weighted.mean, 
             w = weight, 
             na.rm = TRUE), 
    .SDcols = candidate_vars, 
    by = "district"]

census_dt <- 
  census_dt %>%
  as.data.table() %>%
  .[, paste0(candidate_vars, "_targetmean") := 
      lapply(.SD, 
             weighted.mean, 
             na.rm = TRUE), 
    .SDcols = candidate_vars, 
    by = "district"]

#### create regional dummies
survey_dt <- 
  survey_dt %>%
  mutate(dummy = 1) %>%
  pivot_wider(names_from = state,
              names_prefix = "state_",
              values_from = dummy,
              values_fill = list(dummy = 0)) %>%
  dplyr::select(starts_with("state_")) %>%
  rename_with(~ gsub(" ", "", .)) %>%
  cbind(survey_dt)

census_dt <- 
  census_dt %>%
  mutate(dummy = 1) %>%
  pivot_wider(names_from = state,
              names_prefix = "state_",
              values_from = dummy,
              values_fill = list(dummy = 0)) %>%
  dplyr::select(starts_with("state_")) %>%
  rename_with(~ gsub(" ", "", .)) %>%
  cbind(census_dt)


#### lets update the set of candidate variables
candidate_vars <- c(candidate_vars, 
                    colnames(survey_dt)[grepl("state_", colnames(survey_dt))])


```



### Variable Selection

-   Checking that each variable has similar distribution between the survey and census and dropping variables that do not meet (a function has been written to do this test better than the ebp_test_means() function in povmap)
-   Dropping multicollinear variables (using the VIF method and complementing with correlation threshold method)
-   Implementing variable selection under different welfare transformations (use wrapper functions that I have written for the variable selection using glmmLasso and GLMNET R packages)
-   Cross-Fold Validating the variable selection process i.e. a plot to show how MSE for each lambda of glmnet is performed. (May also show how to do this with glmmLasso)

```{r, fig.width = 8}

#### let's create the set of outcome variables for the different potential income transformations we might be interested in doing

###### log transformation
survey_dt <- 
  survey_dt %>%
  mutate(logeqIncome = log(eqIncome))

###### boxcox transformation
#### apply box-cox transformation
boxcox_result <- MASS::boxcox(lm(eqIncome ~ 1, data = survey_dt), 
                              lambda = seq(-2, 2, by = 0.1))

lambda_opt <- boxcox_result$x[which.max(boxcox_result$y)]
cat("Optimal Lambda:", lambda_opt, "\n")

## Apply the transformation manually
if (lambda_opt == 0){
  
  survey_dt <- 
    survey_dt %>%
    mutate(bcxeqIncome = log(eqIncome))
  
} else {
  
  survey_dt <- 
    survey_dt %>%
    mutate(bcxeqIncome = (eqIncome^lambda_opt - 1) / lambda_opt)

}

#### compare the distributions of the outcome variables created
p1 <- 
survey_dt %>%
  ggplot() + 
  geom_histogram(aes(x = logeqIncome), 
                 binwidth = 0.5, 
                 fill = "blue", 
                 color = "black") + 
  labs(title = "Log Income Distribution") + 
  theme_minimal()

p2 <- 
survey_dt %>%
  ggplot() + 
  geom_histogram(aes(x = bcxeqIncome), 
                 binwidth = 0.5, 
                 fill = "red", 
                 color = "black") + 
  labs(title = "Box-Cox Income Distribution") + 
  theme_minimal()

gridExtra::grid.arrange(grobs = list(p1, p2), nrow = 1)

```


```{r}

#' A function for variable selection using the GLMNET R package
#' 
#' This function acts as a wrapper to the GLMNET R package which performs variable selection with nfold cross validation. 
#' 
#' @details This function cleans the data `dt` first by standardizing the predictors, dropping columns with missing values, very low variance (near
#' zero variance), highly correlated variables based on a certain `correlation_threshold`. The function also drops variables with an high percentage #' of zeros based on a `sparsity_threshold`. It then fits the lasso regression with the GLMNET package before returning the best combination of
#' predictive variables based on the `lambda_type` selection criteria. 
#' 
#' 
#' @param dt data.frame or data.table
#' @param candidate_vars character, the set of potential predictors within `dt`
#' @param y character, the variable name of the outcome variable within `dt`
#' @param weights character, weight variable name
#' @param alpha integer, 1 for LASSO and 0 for ridge regression
#' @param nfolds integer, the number of cross fold validations to perform
#' @param seed integer, randomization seed 
#' @param lambda_type, either "lambda.min" or "lambda.1se". see `glmnet::glmnet()` for more information
#' @param correlation_threshold numeric, the threshold for dropping correlated variables (value between 0 and 1)
#' @param variance_threshold numeric, threshold for dropping variables that appear almost constant by specifying a minimum variance that must be met
#' @param sparsity_threshold numeric, threshold for dropping sparse variables
#' 
#' @export
#' 
#' @import glmnet 
#' @importFrom caret findCorrelation

glmnetlasso_vselect <- function(dt, 
                                candidate_vars, 
                                y, 
                                weights, 
                                alpha = 1, 
                                nfolds, 
                                seed = 123,
                                lambda_type = "lambda.min",
                                correlation_threshold = 0.9, # Threshold for dropping correlated variables
                                variance_threshold = 1e-4,
                                sparsity_threshold = 0.99,# Threshold for dropping sparse variables
                                ...) {
  # Load necessary library
  if (!requireNamespace("glmnet", quietly = TRUE)) {
    stop("The glmnet package is required. Please install it.")
  }
  
  if (!requireNamespace("caret", quietly = TRUE)) {
    install.packages("caret")
  }
  
  # Ensure reproducibility
  set.seed(seed)
  
  # Standardize predictors
  X_scaled <- scale(dt[, candidate_vars])
  y <- dt[[y]]
  weights <- dt[[weights]]
  
  # Drop any columns with missing values in X_scaled
  X_scaled <- X_scaled[, colSums(is.na(X_scaled)) == 0]
  
  # Drop variables with very low variance
  variances <- apply(X_scaled, 2, var)
  X_scaled <- X_scaled[, variances > variance_threshold]
  
  # Drop highly correlated variables
  correlation_matrix <- cor(X_scaled)
  high_corr <- caret::findCorrelation(correlation_matrix, 
                                      cutoff = correlation_threshold, 
                                      verbose = FALSE)
  if (length(high_corr) > 0) {
    X_scaled <- X_scaled[, -high_corr]
  }
  
  # Identify and drop variables with 99% or more zeros
  # Calculate proportion of zeros for each column
  proportion_zeros <- colMeans(X_scaled == 0)
  
  # Filter out columns where proportion of zeros is above the threshold
  X_scaled <- X_scaled[, proportion_zeros < sparsity_threshold]
  
  # Check for problematic values
  if (anyNA(X_scaled) || any(is.infinite(X_scaled)) || any(is.nan(X_scaled))) {
    stop("Predictor matrix contains NA, Inf, or NaN values.")
  }
  if (any(weights <= 0)) {
    stop("Weights contain non-positive values.")
  }

  # Fit lasso model with cross-validation
  cv_model <- glmnet::cv.glmnet(
    x = X_scaled,
    y = y,
    weights = weights,
    alpha = alpha,  # alpha = 1 for lasso, 0 < alpha < 1 for elastic net
    nfolds = nfolds,
    family = "gaussian", # Change to "binomial" or "poisson" for other models
    ...
  )
  
  # Extract coefficients at the lambda with minimum cross-validated error
  selected_model <- glmnet::glmnet(
    x = X_scaled,
    y = y,
    weights = weights,
    alpha = alpha,
    lambda = cv_model[[lambda_type]],
    family = "gaussian",
    ...
  )
  
  # Identify selected variables
  selected_variables <- rownames(as.matrix(coef(selected_model)))[as.matrix(coef(selected_model)) != 0]
  selected_variables <- selected_variables[selected_variables != "(Intercept)"]
  
  return(selected_variables)
  
}



#### lets call this function to model selection for each transformation
notglmnet_list <- 
  glmnetlasso_vselect(dt = survey_dt,
                      candidate_vars = candidate_vars,
                      y = "eqIncome",
                      weights = "weight",
                      nfolds = 10,
                      seed = 123,
                      lambda_type = "lambda.1se",
                      sparsity_threshold = 0.99)
 

logglmnet_list <- 
  glmnetlasso_vselect(dt = survey_dt,
                      candidate_vars = candidate_vars,
                      y = "logeqIncome",
                      weights = "weight",
                      nfolds = 10,
                      seed = 123,
                      lambda_type = "lambda.1se",
                      sparsity_threshold = 0.99)
 
bcxglmnet_list <- 
  glmnetlasso_vselect(dt = survey_dt,
                      candidate_vars = candidate_vars,
                      y = "bcxeqIncome",
                      weights = "weight",
                      nfolds = 10,
                      seed = 123,
                      lambda_type = "lambda.1se",
                      sparsity_threshold = 0.99)
 


```



```{r, message=FALSE, warning=FALSE}

### using the ebp function to first estimate into the household survey. We need to see how well the model will estimate poverty first into the training set i.e. the household survey. this helps to check the quality of in-sample estimation without any potential prediction bias

dir.create("data/Ydump")

model_formula <- as.formula(paste0("eqIncome ~ ", paste(logglmnet_list, collapse = " + ")))

log_smodel <- 
  povmap::ebp(fixed = model_formula,
              pop_data = survey_dt[, c(logglmnet_list, "district")],
              pop_domains = "district",
              smp_data = survey_dt[, c("eqIncome", logglmnet_list, "district", "weight")],
              smp_domains = "district",
              MSE = TRUE,
              threshold = 18207.2,
              transformation = "log",
              B = 50,
              L = 50,
              weights = "weight",
              rescale_weights = TRUE,
              Ydump = "data/Ydump/unitsurvey_logYdump_glmnet.csv",
              cpus = 30)

saveRDS(log_smodel, "data/log_surveymodel.RDS")

model_formula <- as.formula(paste0("eqIncome ~ ", paste(bcxglmnet_list, collapse = " + ")))

bcx_smodel <- 
  povmap::ebp(fixed = model_formula,
              pop_data = survey_dt[, c(bcxglmnet_list, "district")],
              pop_domains = "district",
              smp_data = survey_dt[, c(bcxglmnet_list, "district", "eqIncome", "weight")],
              smp_domains = "district",
              MSE = TRUE,
              threshold = 18207.2,
              transformation = "box.cox",
              B = 50,
              L = 50,
              weights = "weight",
              rescale_weights = TRUE,
              Ydump = "data/Ydump/unitsurvey_bcxYdump_glmnet.csv",
              cpus = 30,
              weights_type = "nlme_lambda")
saveRDS(bcx_smodel, "data/bcx_surveymodel.RDS")


model_formula <- as.formula(paste0("eqIncome ~ ", paste(notglmnet_list, collapse = " + ")))

not_smodel <- 
  povmap::ebp(fixed = model_formula,
              pop_data = survey_dt[, c(notglmnet_list, "district")],
              pop_domains = "district",
              smp_data = survey_dt[, c(notglmnet_list, "district", "eqIncome", "weight")],
              smp_domains = "district",
              MSE = TRUE,
              threshold = 18207.2,
              transformation = "no",
              B = 50,
              L = 50,
              weights = "weight",
              rescale_weights = TRUE,
              Ydump = "data/Ydump/unitsurvey_notYdump_glmnet.csv",
              cpus = 30)
saveRDS(not_smodel, "data/not_surveymodel.RDS")


### then we actually estimate the census level estimation

model_formula <- as.formula(paste0("eqIncome ~ ", paste(logglmnet_list, collapse = " + ")))

log_model <- 
  povmap::ebp(fixed = model_formula,
              pop_data = census_dt[, c(logglmnet_list, "district")],
              pop_domains = "district",
              smp_data = survey_dt[, c("eqIncome", logglmnet_list, "district", "weight")],
              smp_domains = "district",
              MSE = TRUE,
              threshold = 18207.2,
              transformation = "log",
              B = 50,
              L = 50,
              weights = "weight",
              rescale_weights = TRUE,
              Ydump = "data/Ydump/unitcensus_logYdump_glmnet.csv",
              cpus = 30)
saveRDS(log_model, "data/log_censusmodel.RDS")


model_formula <- as.formula(paste0("eqIncome ~ ", paste(bcxglmnet_list, collapse = " + ")))

bcx_model <- 
  povmap::ebp(fixed = model_formula,
              pop_data = census_dt[, c(bcxglmnet_list, "district")],
              pop_domains = "district",
              smp_data = survey_dt[, c(bcxglmnet_list, "district", "eqIncome", "weight")],
              smp_domains = "district",
              MSE = TRUE,
              threshold = 18207.2,
              transformation = "box.cox",
              B = 50,
              L = 50,
              weights = "weight",
              rescale_weights = TRUE,
              Ydump = "data/Ydump/unitcensus_bcxYdump_glmnet.csv",
              cpus = 30,
              weights_type = "nlme_lambda")

saveRDS(bcx_model, "data/bcx_censusmodel.RDS")


model_formula <- as.formula(paste0("eqIncome ~ ", paste(notglmnet_list, collapse = " + ")))

not_model <- 
  povmap::ebp(fixed = model_formula,
              pop_data = census_dt[, c(notglmnet_list, "district")],
              pop_domains = "district",
              smp_data = survey_dt[, c(notglmnet_list, "district", "eqIncome", "weight")],
              smp_domains = "district",
              MSE = TRUE,
              threshold = 18207.2,
              transformation = "no",
              B = 50,
              L = 50,
              weights = "weight",
              rescale_weights = TRUE,
              Ydump = "data/Ydump/unitcensus_notYdump_glmnet.csv",
              cpus = 30)


saveRDS(not_model, "data/not_censusmodel.RDS")




```

### EBP Unit Level Model Estimation

-   Start with a few notes on the pre-reqs needed to use the ebp() function in EMDI/povmap R packages i.e.
    -   all target areas (domain argument) in the survey must be in the census
    -   domain argument must be integer class
    -   remove all missing observations in survey and census
-   Implementation of the ebp() function call
-   Detailed description of the ebp class object which is returned


```{r}

#### first let us look at the quality of in-sample prediction

ebp_national_pov <- function(ebp_obj,
                             wgt_var,
                             pop_domain,
                             est_domain,
                             pop_dt,
                             indicators = c("Head_Count")) {
  
  
  pop_dt <- 
    pop_dt %>%
    group_by(!!sym(pop_domain), !!sym(est_domain)) %>%
    summarise(population = sum(!!sym(wgt_var), na.rm = TRUE), .groups = "drop")
  
  # Merge the ebp object data with population data
  dt <- merge(ebp_obj$ind, 
              pop_dt[, c(pop_domain, "population", est_domain)], 
              by.x = "Domain", 
              by.y = pop_domain, 
              all.x = TRUE)
  
  # Compute weighted means for all indicators
  
  pov_dt <- 
    dt %>%
    as.data.table() %>%
    .[, lapply(.SD, weighted.mean, w = population, na.rm = TRUE),
      .SDcols = indicators,
      by = est_domain]

  return(pov_dt)
  
}


ebpsurveypov_dt <- lapply(X = list(not_smodel, bcx_smodel, log_smodel),
                          FUN = function(ebp_obj){
                            
                            z <- ebp_national_pov(ebp_obj = ebp_obj, 
                                                  wgt_var = "weight", 
                                                  pop_domain = "district", 
                                                  pop_dt = survey_dt,
                                                  est_domain = "state") 

                            return(z)
                            
                          })

### rename headcount columns appropriately

ebpsurveypov_dt <- 
  mapply(pov_dt = ebpsurveypov_dt,
         name_obj = c("not", "bcx", "log"),
         FUN = function(pov_dt, name_obj){
            
            pov_dt <- 
              pov_dt %>%
              rename_with(~ paste0(name_obj, .), .cols = "Head_Count")
            
            return(pov_dt)
           
         },
         SIMPLIFY = FALSE)


ebpsurveypov_dt <- Reduce(f = merge,
                          x = ebpsurveypov_dt)


### we create some fake clusters within the districts to show how to use the survey package
### to estimate the standard errors on the poverty rates

#### for simplicity we will assume there are 5 clusters in each district

survey_dt <- 
survey_dt %>%
  group_by(district) %>%
  mutate(num_clusters = pmax(2, round(n() / sample(5:15, 1))),
         cluster = sample(rep(1:num_clusters, length.out = n()))) %>%
  ungroup() %>%
  mutate(cluster_id = dense_rank(interaction(district, cluster)))


svy_obj <- 
survey_dt %>%
  mutate(poor = ifelse(eqIncome < 18207.2, 1, 0)) %>%
  dplyr::select(district, weight, state, poor, cluster_id) %>%
  survey::svydesign(ids = ~cluster_id,
                    weights = ~weight,
                    strata = ~state,
                    survey.lonely.psu = "adjust",
                    data = .)

var_dt <- 
  svyby(~poor, ~state, svy_obj, svymean) %>%
  mutate(poorLB = poor - 1.96*se,
         poorUB = poor + 1.96*se) 

ebpsurveypov_dt <- merge(ebpsurveypov_dt, 
                         var_dt[, c("state", "poor", "poorLB", "poorUB")] %>%
                           as.data.frame(),
                         by = "state")


#### it is also important to look at the predictive power of the model estimation in the training set (i.e. the survey) at each poverty map
#### here I show how chart that compares the poverty rates at each poverty ventile and the estimated poverty rates

ydumppath_list <- list.files(path = "data/Ydump",
                             pattern = "^unitsurvey_.*Ydump_glmnet.csv",
                             full.names = TRUE)

### the following code will read in the Ydump data into a list of data.frame objects and sequentially: 
### - combine the ydump with household survey
### - compute poverty rates at each threshold

#### lets write a function to do this for one of our models

ydump_dtlist <- lapply(X = ydumppath_list,
                       FUN = fread)


names(ydump_dtlist) <- 
    basename(ydumppath_list) %>%
    sub(pattern = "^unitsurvey_", replacement = "") %>%
    sub(pattern = "_glmnet.csv", replacement = "")


### a simple function to carry out the poverty rate comparisons (model vs actual at each poverty ventile, 5% increments) & plot the result

compare_surveyebp_atpovline <- function(ydump_data,
                                        smp_data,
                                        smp_domains,
                                        smp_weights,
                                        outcome_var,
                                        pline_increment = seq(0, 1, 0.05)){
  
  ydump_dt <- as.data.table(ydump_data)
  smp_dt <- as.data.table(smp_data[, c(smp_domains, smp_weights, outcome_var)])
  
  ydump_dt <- cbind(ydump_dt, 
                    smp_dt[, c(smp_domains, smp_weights), with = FALSE] %>%
                      arrange(smp_domains))
  
  threshold_list <-
    wtd.quantile(x = smp_dt[[outcome_var]],
                 weights = smp_dt[[smp_weights]],
                 probs = pline_increment)
  
  compute_ptile_pov <- function(welfare_dt,
                                weights,
                                welfare,
                                thresholds){
  
    pov_list <- 
    lapply(X = thresholds,
           FUN = function(x){
             
             yy <- 
               welfare_dt %>%
               mutate(poor = ifelse(!!sym(welfare) < x, 1, 0)) %>%
               summarize(prate = weighted.mean(x = poor,
                                               w = !!sym(weights),
                                               na.rm = TRUE))
             
             return(yy)
             
           })
    
    pov_list <- 
      unlist(pov_list) %>%
      data.frame() %>%
      setNames("pov")
    
    
    return(pov_list)
    
  }
  
  pov_dt <- compute_ptile_pov(welfare_dt = ydump_dt,
                              weights = smp_weights,
                              welfare = "Simulated_Y",
                              thresholds = threshold_list)
  
  pov_dt <- data.table(ebp_poverty = pov_dt,
                       probs = as.character(seq(0, 1, 0.05)))

  
  # povcheck_plots <- 
  #   pov_dt %>%
  #   mutate(y )
  #   ggplot(aes(x = as.numeric(probs)))
  
  return(pov_dt)
  
}

### now lets plot the results

svyplinecomp_list <- 
  lapply(X = ydump_dtlist,
         FUN = function(ydump) {
           compare_surveyebp_atpovline(ydump_data = ydump,
                                       smp_data = survey_dt,
                                       smp_domains = "district",
                                       smp_weights = "weight",
                                       outcome_var = "eqIncome")
         })

## a bit of cleaning and then making the plots

svyplinecomp_dt <- 
  mapply(comp_dt = svyplinecomp_list,
         name_list = names(svyplinecomp_list),
         FUN = function(comp_dt, name_list) {
           
           comp_dt <- 
             comp_dt %>%
             rename(ebp = "ebp_poverty.pov") %>%
             mutate(probs = as.numeric(probs)) %>%
             mutate(diff = ebp - probs) %>%
             mutate(transformation = sub("Ydump", "", name_list))
           
 
           
 
           return(comp_dt)
           
         }, SIMPLIFY = FALSE)

svyplinecomp_dt <- Reduce("rbind", svyplinecomp_dt)

svyplinecomp_dt %>%
  ggplot() +
  geom_line(aes(x = probs,
                y = diff,
                color = transformation)) + 
  theme_minimal()



```


### Post Estimation Diagnostics

-   Presenting the regression table estimates (use povmap::ebp_reportcoef_table() and then translate into a flextable which can be rendered in Word, PDF or HTML)
-   Checking that all model assumptions hold (normality assumptions for the miu and epsilon terms), using povmap::ebp_normalityfit() to present skewness and kurtosis for both errors. Then show a function that uses ebp object to plot the distribution of the errors and compute the kolmogrov-smirnov test statistics. We can also include the shapiro-wilks which will break down for larger sample sizes but is equally well known. Another function that produces q-q plots for miu and epsilon terms from ebp object.
-   Check on model validity: Create a plot to show how poverty rates vary at each ventile i.e. at 5% poverty line increments. This is to show how to check the quality of model prediction without the added bias of out of sample prediction
-   Computing MSE and CVs and computing the statistical gains made from performing small area estimation i.e. in practical terms, how much bigger would the survey have to be the get the same level of precision that SAE now gives us with the census data.
-   Final validation: EBP estimates vs Direct Estimates (supposedly truth) at the highest resolution level that is considered nationally representative, this is usually the regional level in Africa.
-   Plotting the poverty map using the ebp object and the shapefile



```{r}

#### presenting the results of the linear mixed effects regression

specify_decimal <- function(x, k) trimws(format(round(x, k), nsmall=k))

coef_dt <- povmap::ebp_reportcoef_table(log_model) ### to quickly create coefficients table

err_dt <- ## showing how to present the skewness and kurtosis of the random effects and model errors
  povmap::ebp_normalityfit(log_model) %>%
  mutate(value = specify_decimal(value, 3))


### to convert this into a publication ready report

create_regression_table <- function(coef_table, eval_table) {
  
  # Rename columns for consistency
  coef_table <- 
    coef_table %>%
    rename(Description = Variable, Estimate = coeff, `Std. Error` = std_error) %>%
    mutate(Type = "Coefficients") %>%
    mutate(Estimate = paste0(Estimate, "\n(", `Std. Error`, ")")) %>%  # Format std. error under estimates
    dplyr::select(Type, Description, Estimate)

  eval_table <- eval_table %>%
    rename(Description = indicator, Estimate = value) %>%
    mutate(Type = "Diagnostics")

  # Combine coefficient and diagnostic tables
  full_table <- rbind(coef_table, 
                      eval_table %>%
                        dplyr::select(colnames(coef_table)))

  # Identify where diagnostics start
  diag_start <- nrow(coef_table) + 1

  # Create flextable
  regression_table <- 
  flextable(full_table) %>%
    set_header_labels(
      Type = "Type",
      Description = "Description",
      Estimate = "Estimate"
    ) %>%
    hline(part = "all") %>%
    merge_v(j = "Type") %>%
    align(j = "Description", align = "left", part = "all") %>%
    align(j = "Estimate", align = "center", part = "all") %>%
    vline(j = 1, border = fp_border(color = "black", width = 1)) %>%
    hline(i = diag_start - 1, border = fp_border(color = "black", width = 1)) %>%
    autofit() %>%
    width(j = "Type", width = 1.2) %>%
    width(j = "Description", width = 2) %>%
    width(j = "Estimate", width = 1.5)

  # Styling for diagnostics
  regression_table <- regression_table %>%
    bold(i = diag_start:nrow(full_table), bold = TRUE) %>%
    italic(i = diag_start:nrow(full_table), italic = TRUE) %>%
    font(fontname = "Times New Roman", part = "all") %>%
    fontsize(size = 10, part = "all")

  return(regression_table)
  
}


### regression tables
create_regression_table(coef_table = coef_dt,
                        eval_table = err_dt)

```


```{r}

### start by explaining that the plot function could be used in R to show the error diagnostics as follows
plot(log_model)


### a more thorough test on normality using the Kolmogrov-Smirnov tests

ebp_kstest <- function(ebp_obj){
  
  epsilon_values <- as.numeric(residuals(ebp_obj$model, level = 0, type = "pearson"))

  mu_values <- as.numeric(nlme::ranef(ebp_obj$model)$"(Intercept)")
  
  mu_values <- (mu_values - mean(mu_values, na.rm = TRUE)) / sd(mu_values, na.rm = TRUE)
  
  xx <- ks.test(epsilon_values, "pnorm", mean = mean(epsilon_values), sd = sd(epsilon_values))
  
  yy <- ks.test(mu_values, "pnorm", mean = mean(mu_values), sd = sd(mu_values))
  
  plot_random <- 
    mu_values %>%
    as.data.table() %>%
    setnames(new = "values") %>%
    ggplot() + 
    geom_density(aes(x = values), fill = "blue", alpha = 0.5) + 
    labs(x = "Random Effects", y = "Density", title = "Random Effect Residuals (\u03BC)") + 
    theme_minimal() + 
    ylim(0, 0.4) + 
    xlim(-4, 4) + 
    annotate("richtext", x = 0, y = 0.3, label = "<b>Kolmogrov-Smirnov Normality Test</b>", 
             fill = NA, label.color = NA) + 
    annotate("text", x = 0, y = 0.28, label = paste0("D-stat = ", 
                                                    specify_decimal(yy$statistic, 3),
                                                    "; p-value = ", 
                                                    specify_decimal(yy$p.value, 3)), 
             size = 3)
  
  plot_error <- 
    epsilon_values %>%
    as.data.table() %>%
    setnames(new = "values") %>%
    ggplot() + 
    geom_density(aes(x = values), fill = "blue", alpha = 0.5) + 
    labs(x = "Model Error Terms", y = "Density", title = "Standardized Error Residuals (\u03B5)") + 
    theme_minimal() + 
    annotate("richtext", x = 0.75, y = 0.3, label = "<b>Kolmogrov-Smirnov Normality Test</b>", 
             fill = NA, label.color = NA) + 
    annotate("text", x = 0, y = 0.28, label = paste0("D-stat = ", 
                                                     specify_decimal(xx$statistic, 3),
                                                     "; p-value = ", 
                                                     specify_decimal(xx$p.value, 3)), 
             size = 3)
  
  
  p <- grid.arrange(grobs = list(plot_random, plot_error), nrow = 1)  
    
  
  return(p)
  
}

ebp_kstest(log_model)



```



### CV Estimation
```{r}

### it is important to compare Coefficient of Variation between the survey direct estimates and the census computations. 

#### first using the povmap::direct() function to estimate the direct and model estimate cvs for the poverty rates

ebp_compare_cv <- function(ebp_obj, ...) {
  
  # Convert to data.table
  ind_dt <- as.data.table(ebp_obj$ind)
  mse_dt <- as.data.table(ebp_obj$MSE)

  # Ensure mse_dt and ind_dt are numeric except Domain
  mse_numeric <- mse_dt[, !("Domain"), with = FALSE]
  ind_numeric <- ind_dt[, !("Domain"), with = FALSE]

  # Compute CV
  ebpcv_dt <- sqrt(mse_numeric) / ind_numeric

  # Add Domain back
  ebpcv_dt[, Domain := ind_dt$Domain]

  # Compute direct estimation
  direct_dt <- povmap::direct(...)

  # Identify numeric columns common to both
  common_cols <- intersect(names(direct_dt$ind), names(direct_dt$MSE))
  numeric_cols <- common_cols[sapply(as.data.table(direct_dt$ind)[, ..common_cols], is.numeric)]

  # Compute CV for direct estimation
  directcv_dt <- sqrt(as.data.table(direct_dt$MSE)[, ..numeric_cols]) / 
                 as.data.table(direct_dt$ind)[, ..numeric_cols]

  # Add Domain back and rename
  directcv_dt <- 
    cbind(as.data.table(direct_dt$ind)[, .(Domain)], directcv_dt) %>%
          dplyr::select(Domain, Head_Count) %>%
          rename(HT_Head_Count = Head_Count)

  # Merge direct and EBP results
  cv_dt <- directcv_dt[ebpcv_dt, on = "Domain"]

  # Rename columns for clarity
  setnames(cv_dt, "Head_Count", "Head_Count_CV")
  setnames(cv_dt, "HT_Head_Count", "HT_Head_Count_CV")

  return(cv_dt)
  
}


cv_dt <- ebp_compare_cv(ebp_obj = log_model,
                        y = "eqIncome",
                        smp_data = survey_dt,
                        smp_domains = "district",
                        weights = "weight",
                        var = TRUE,
                        threshold = 18207.2,
                        design = "state",
                        na.rm = TRUE,
                        HT = TRUE)


### it is useful to be able to be able to figure out how 
gains_value <- 
  cv_dt %>%
  mutate(gains = HT_Head_Count_CV / Head_Count_CV) %>%
  summarize(mean(gains, na.rm = TRUE))

#### create visualization to show how the EBP CVs are an improvement on the Horwitz-Thompson Headcount CVs
#### as a result of SAE

cv_dt %>%
  ggplot() + 
  geom_point(aes(y = Head_Count_CV, x = HT_Head_Count_CV)) + 
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "blue") + 
  labs(x = "Horwitz-Thompson Headcount CV",
       y = "EBP Head Count CV") + 
  xlim(0, 1.5) + 
  ylim(0, 1.5) + 
  scale_color_viridis_d(option = "plasma") + 
  theme_minimal()



```































