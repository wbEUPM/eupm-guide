[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EUPM Practitioners Guide",
    "section": "",
    "text": "Introduction\nTODO",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Small Area Estimations for the poverty mapping: an overview",
    "section": "",
    "text": "As discussed with Nobuo, Danielle and Eduard, place for an practitioners overview chapter.\nSome overview ideas:\n\nMake a decision tree of methodology given data availability.\nMake a table to take a stock of methods and Corresponding R funciton/packages that implement it. For example, see Table 1.1\n\n\n\n\nTable 1.1: Methods overview\n\n\n\n\n\n\n\n\n\n\n\nMethods\nsae\nemdi\nSUMMER\n\n\n\n\nSpatial Fay-Herriot\nsae::mseFH()\n\nSUMMER::smoothArea()\n\n\nFH Miltivariate\n\n\n\n\n\nAutocorrelation\n\n\n\n\n\n\n\n\n\nPlace figures under images and use them in the text as follows making sure to refer the sources correctly. For example, Figure 1.1 is adapted from (Corral et al. 2022, 5).\n\n\n\n\n\n\nFigure 1.1: SAE decision tree\n\n\n\nOne can also embed mathematical formulas following the latex syntax: \\(y=a + b \\log x\\) . For more information, see quarto help on authoring.\n\n\n\n\n\n\nCorral, Paul, Isabel Molina, Alexandru Cojocaru, and Sandra Segovia. 2022. Guidelines to Small Area Estimation for Poverty Mapping. World Bank Washington.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Small Area Estimations for the poverty mapping: an overview</span>"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "2  Data preparation",
    "section": "",
    "text": "2.1 Workflow and reproducibility principals\nIntroduction: this chapter provides a template for organizing the data flow in the EUPM analysis.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data preparation</span>"
    ]
  },
  {
    "objectID": "data.html#workflow-and-reproducibility-principals",
    "href": "data.html#workflow-and-reproducibility-principals",
    "title": "2  Data preparation",
    "section": "",
    "text": "Brief overview of the data workflow between raw, auxiliary and clean data types.\nBasic principles of reproducibility.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data preparation</span>"
    ]
  },
  {
    "objectID": "data.html#geospatial-data",
    "href": "data.html#geospatial-data",
    "title": "2  Data preparation",
    "section": "2.2 Geospatial data",
    "text": "2.2 Geospatial data\n\nDescription of the basics of the GIS data preparation for countries at different admin levels. Key problems addressed.\nSpatial validity of polygons.\nNested geospatial structure and non-intersecting boundaries.\nPolygon -unique identifiers.\nGIS boundaries harmonization over time.\n\nSynthetic regions aggregation constant in time\n\nQuality assurance of the administrative boundaries.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data preparation</span>"
    ]
  },
  {
    "objectID": "data.html#raw-data-search-collection-and-documentation",
    "href": "data.html#raw-data-search-collection-and-documentation",
    "title": "2  Data preparation",
    "section": "2.3 Raw data search, collection, and documentation",
    "text": "2.3 Raw data search, collection, and documentation\nDescription of the process of data search, collection and documentation that yields with a systematized, but unstructured data library\n\nVariables search, and priority indicators.\nKey challenges and considerations for data inclusion:\n\nThematic relevance\nTime range available\nTerritorial unit available\nCoverage and completeness\n\nDetails on specific data sources:\n\nAPI-based data\nManually downloaded spreadsheets\nBulk downloads\nRemote sensing and GIS-based data, zonal statistcs, etc.\n\nPrincipals of data storage and systematization\nDocumenting collected data with metadata and it notes on search\n\nKey validation requirements – source type, survey type\n\n\nCountry-based examples: use one country as an example.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data preparation</span>"
    ]
  },
  {
    "objectID": "data.html#preparing-auxiliary-data",
    "href": "data.html#preparing-auxiliary-data",
    "title": "2  Data preparation",
    "section": "2.4 Preparing auxiliary data",
    "text": "2.4 Preparing auxiliary data\nAdding structure to the raw data by transforming it into a normalized data set with columns: id, year, variable, value.\n\ncreating and storing the auxiliary data\ndata reproduction and version-control\nprincipals of the data quality assurance and quality control\n\nCountry-based examples: use one country as an example.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data preparation</span>"
    ]
  },
  {
    "objectID": "data.html#clean-and-analysis-ready-data",
    "href": "data.html#clean-and-analysis-ready-data",
    "title": "2  Data preparation",
    "section": "2.5 Clean and analysis-ready data",
    "text": "2.5 Clean and analysis-ready data\nGetting meaningful and relevant indicators out of the data.\n\nReshaping auxiliary data into the analysis-ready dataset.\nComputing relevant indicators: means, ratios, fractions, etc.\n\nGroup-wise operations by year, and across regions.\n\nRegression-data quality assurance: spatial and temporal completeness\nAdding data important data from elsewhere: SILK poverty estimates",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data preparation</span>"
    ]
  },
  {
    "objectID": "data.html#descriptive-analysis",
    "href": "data.html#descriptive-analysis",
    "title": "2  Data preparation",
    "section": "2.6 Descriptive analysis",
    "text": "2.6 Descriptive analysis\nKey principals and examples of descriptive statistics.\n\nExamples of existing R functional for this.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data preparation</span>"
    ]
  },
  {
    "objectID": "ul.html",
    "href": "ul.html",
    "title": "3  Unit-Level Models",
    "section": "",
    "text": "3.1 Introduction\nIn this section, we will present an implementation of the Empirical Best Prediction (EBP) unit modelling approach in R based on World Bank’s Small Area Estimation Guidelines, (Corral et al. 2022), as well as (Molina and Rao 2010) and (Rao and Molina 2015). Similar to the disclaimer made in the previous section, this practical manual does not present a theoretical statistical primer on unit level poverty mapping. Rather, it presents a combination of practical and simple R scripts with appropriate explanations to expose the simplicity of performing these tasks in R to the user. The studies previously cited are excellent starting points for those interested in understanding the theoretical underpinnings for the code being presented here.\nThis chapter is subdivided as follows to show the whole game of the EBP linear mixed effect modelling approach:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unit-Level Models</span>"
    ]
  },
  {
    "objectID": "ul.html#introduction",
    "href": "ul.html#introduction",
    "title": "3  Unit-Level Models",
    "section": "",
    "text": "The Data: In this subsection, we present a brief checklist of data items needed for the unit level poverty mapping as well as present the specific data to be used in this chapter.\nData Preparation: Here we present the process of transforming the data in\ninto what is needed for variable selection and then estimating a unit level poverty map\nVariable Selection: We present the LASSO methodology of the GLMNET, glmmLasso and hdm R packages as well as another implementation that uses the stepwise model\nEBP Unit Level Model Estimation: Having selected the set of variables, we proceed to use the povmap package’s povmap::ebp() function to estimate the poverty map.\nPost Estimation Diagnostics: We proceed to test model assumptions of the EBP linear mixed effects model and present functions within the povmap package for producing report ready figure and tables.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unit-Level Models</span>"
    ]
  },
  {
    "objectID": "ul.html#the-data",
    "href": "ul.html#the-data",
    "title": "3  Unit-Level Models",
    "section": "3.2 The Data",
    "text": "3.2 The Data\nThe main idea of SAE is to combine multiple data sources. Typically, there is a survey data set and a census or administrative/register dataset both at an individual and/or household unit level. The target variable (typically household welfare/income for poverty mapping) is available in the survey but not in the census data. The goal of the exercise is to estimate welfare/income for each unit within the census or administrative register dataset by developing a model of welfare or income within the survey. It is important that the outcome variable has the same definition within the census or administrative dataset as the case maybe. It would be inappropriate to estimate household welfare/income within the survey and use the same model to predict income at the individual level of the census. Below is a brief checklist of data requirements needed for unit level poverty mapping with the povmap R package:\n\nA unit level survey data.frame object with individual and household characteristics including the target area variable, outcome variable (welfare aggregates, income per capita etc)\nA unit census/administrative register dataframe object with individual and household characteristics including the target area variable. The outcome variable is typically missing since the topic of this tutorial is estimating it.\n\nFor the purposes of this tutorial, we will use the European Union Statistics on Income and Living Conditions (EU-SILC) in Austria from 2006. Please see (Kreutzmann et al. 2019) for the full description of the dataset\n\n### load the data\nsurvey_dt &lt;- eusilcA_smp |&gt; as_tibble()\n\n## ignore the eqIncome variable that has been left in the eusilcA_pop dataset\ncensus_dt &lt;- eusilcA_pop |&gt; as_tibble()\n\n#### the survey dataset\nglimpse(survey_dt)\n\nRows: 1,945\nColumns: 18\n$ eqIncome    &lt;dbl&gt; 23485.320, 22704.460, 25946.340, 16152.538, 22587.480, 204…\n$ gender      &lt;fct&gt; male, male, female, male, male, male, female, male, female…\n$ eqsize      &lt;dbl&gt; 2.5, 2.0, 1.0, 2.1, 1.5, 2.0, 1.5, 2.0, 1.8, 1.5, 1.5, 1.0…\n$ cash        &lt;dbl&gt; 33003.39, 20073.23, 0.00, 19972.35, 21503.23, 22282.23, 21…\n$ self_empl   &lt;dbl&gt; 0.00, 0.00, 24736.06, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, …\n$ unempl_ben  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ age_ben     &lt;dbl&gt; 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 15219.13, 3956.04, 0.0…\n$ surv_ben    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ sick_ben    &lt;dbl&gt; 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 3016.55, 0.00, 0.00, 0…\n$ dis_ben     &lt;dbl&gt; 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00…\n$ rent        &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ fam_allow   &lt;dbl&gt; 0.00, 0.00, 0.00, 5247.33, 2031.03, 0.00, 0.00, 0.00, 1860…\n$ house_allow &lt;dbl&gt; 0.00, 0.00, 1083.95, 0.00, 0.00, 3312.42, 0.00, 0.00, 0.00…\n$ cap_inv     &lt;dbl&gt; 17158.84, 4.70, 126.33, 195.32, 19.92, 0.00, 5.96, 1.05, 0…\n$ tax_adj     &lt;dbl&gt; -10972.65, -940.77, 0.00, 0.00, 0.00, 0.00, 0.00, -526.30,…\n$ state       &lt;chr&gt; \"Burgenland\", \"Burgenland\", \"Burgenland\", \"Burgenland\", \"B…\n$ district    &lt;fct&gt; Neusiedl am See, Neusiedl am See, Neusiedl am See, Neusied…\n$ weight      &lt;dbl&gt; 9.6875, 9.6875, 9.6875, 9.6875, 9.6875, 9.6875, 9.6875, 9.…\n\n#### the census dataset\nglimpse(census_dt)\n\nRows: 25,000\nColumns: 17\n$ eqIncome    &lt;dbl&gt; 81304.78, 78017.33, 70096.30, 66120.34, 65166.87, 66703.96…\n$ gender      &lt;fct&gt; female, female, female, male, female, male, female, female…\n$ eqsize      &lt;dbl&gt; 2.1, 2.0, 1.8, 1.5, 2.0, 1.8, 2.3, 3.0, 1.8, 2.1, 1.5, 1.5…\n$ cash        &lt;dbl&gt; 51722.85, 0.00, 16259.90, 0.00, 14272.49, 99867.41, 22551.…\n$ self_empl   &lt;dbl&gt; 0.00, 24399.91, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, …\n$ unempl_ben  &lt;dbl&gt; 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00…\n$ age_ben     &lt;dbl&gt; 0.00, 0.00, 0.00, 51131.52, 0.00, 0.00, 0.00, 0.00, 0.00, …\n$ surv_ben    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ sick_ben    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ dis_ben     &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ rent        &lt;dbl&gt; 90994.14, 104914.06, 0.00, 0.00, 54269.12, 0.00, 93416.01,…\n$ fam_allow   &lt;dbl&gt; 34641.47, 0.00, 28256.15, 0.00, 35017.15, 5036.37, 3778.09…\n$ house_allow &lt;dbl&gt; 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 3554…\n$ cap_inv     &lt;dbl&gt; 0.00, 262.29, 64799.93, 1983.63, 0.00, 388.84, 4865.42, 0.…\n$ tax_adj     &lt;dbl&gt; 40947.36, -349.71, -1126.10, 0.00, -376.87, 0.00, -5838.50…\n$ state       &lt;chr&gt; \"Vorarlberg\", \"Vorarlberg\", \"Vorarlberg\", \"Vorarlberg\", \"V…\n$ district    &lt;fct&gt; Bregenz, Bregenz, Bregenz, Bregenz, Bregenz, Bregenz, Breg…\n\n\n\nAll target areas within the survey must be present within the census.\nThe emdi::ebp() and povmap::ebp() function calls will result in an error message if values in the target area variable are missing within the survey, this includes NA values within the survey target area column that are not in the census’ target area column.\n\n\n### counting the number of districts (i.e. target areas) \n### within the survey that are not a subset of the census districts. \n\n### When 0 is returned below: there are no areas as such\nsurvey_dt |&gt; anti_join(census_dt, join_by(district)) |&gt; nrow()\n\n[1] 0\n\n\nOther important data for poverty mapping include:\n\nA shapefile of the sub-national boundaries.\nWhile a table of poverty rates would suffice, a picture is worth more than a 1000 words and as such emdi and povmap have functionality for converting the resulting estimates into a map using the plot() function within the emdi and povmap packages. It is essential that the target area variable in the census and survey (which by now should be consistent between the survey and census) should also match with the target area variable within the shapefile in order to use the plot() function within emdi or povmap.\n\nOnce the following steps have been taken, the next stage is to prepare the set of variables for estimating a model of household welfare and predicting the consumption aggregates into the census.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unit-Level Models</span>"
    ]
  },
  {
    "objectID": "ul.html#data-preparation-for-unit-level-model",
    "href": "ul.html#data-preparation-for-unit-level-model",
    "title": "3  Unit-Level Models",
    "section": "3.3 Data Preparation for unit level model",
    "text": "3.3 Data Preparation for unit level model\nIn this section, we describe a few common techniques for creating variables with strong correlations to the outcome variable. This includes creating:\n\nvariable interactions\ntarget area average variables\ndummy variables (at the lowest level of national representation, regional dummies, as well as other dummy variables to capture some non-linear relationships between the certain variables and the outcome variable)\n\nFirst a little bit of housekeeping is in order:\n\n### subset the set of candidate variables into a character vector\ncandidate_vars &lt;- survey_dt |&gt; \n  dplyr::select(-any_of(c(\"eqIncome\", \"weight\", \"state\", \"district\"))) |&gt; \n  names()\n\n### we have to ensure candidate variables are numbers:\n###   (numeric or integer class)\n### the only variable that does not meet this criteria is the \n### gender variable\nsurvey_dt &lt;- survey_dt |&gt;\n  mutate(gender = ifelse(gender == \"female\", 1, 0))\n\ncensus_dt &lt;- census_dt |&gt;\n  mutate(gender = ifelse(gender == \"female\", 1, 0))\n\n\n3.3.1 Creating Variable Interactions\nThe create_interactions() function employed in the subsequent code block interacts a specified variable interacter_var with a list of variables of interest var_list. This should be applied to both census and survey data to ensure the same variables are created in both instances.\n\n### show the function we have used to automate interactions between variables\n\n#' A function to interact a variables with a set of variables\n#' \n#' @param dt a data.frame\n#' @param interacter_var the variable to be interacted\n#' @param var_list the set of variables to interact with\n#' \n#' @export\n#' \ncreate_interactions &lt;- function(dt, interacter_var, var_list) {\n  # Ensure dt is a data.table\n  if (!\"data.frame\" %in% class(dt)) {\n    dt &lt;- as.data.table(dt)\n  }\n  \n  # Check if interacter_var exists in the dataset\n  if (!(interacter_var %in% names(dt))) {\n    stop(paste(interacter_var, \"not found in dataset\"))\n  }\n  \n  # Check if var_list contains valid variables that exist in the dataset\n  if (any(!var_list %in% names(dt))) {\n    stop(\"Some variables in var_list are not found in the dataset.\")\n  }\n  \n  # Create an empty data.table to store interactions\n  int_dt &lt;- data.frame(matrix(nrow = nrow(dt)))\n  \n  # Loop over var_list to create interaction terms\n  for (var in var_list) {\n    interaction_name &lt;- paste0(var, \"_X_\", interacter_var)\n    int_dt[[interaction_name]] &lt;- dt[[var]] * dt[[interacter_var]]\n  }\n  \n  int_dt &lt;- int_dt[, -1]\n  return(int_dt)\n}\n\n\nsurvey_dt &lt;- survey_dt |&gt; \n  bind_cols(\n    create_interactions(\n      dt = survey_dt,\n      interacter_var = \"gender\",\n      var_list = candidate_vars[!candidate_vars %in% \"gender\"]\n      ) |&gt; \n      as_tibble()\n    )\n\ncensus_dt &lt;- census_dt |&gt; \n  bind_cols(\n    create_interactions(\n      dt = census_dt,\n      interacter_var = \"gender\",\n      var_list = candidate_vars[!candidate_vars %in% \"gender\"]\n      ) |&gt; \n      as_tibble()\n    )\n\n\n\n3.3.2 Computing target area averages and regional dummies\nIt is often useful to compute target area averages to improve the explanation of intra-area variation in the dependent variable. Below is some efficient code that employs the power of the data.table package to compute the averages and simultaneously include them within the census and survey datasets.\nIn addition, creating dummy variables for the lowest resolution administrative division which is also national representative may help control for some unobserved regional heterogeneity, improving model fit and prediction accuracy, capture spatial dependence in welfare patterns. In rear cases, it should be noted that dummy variables with too few observations in any class might introduce high multicollinearity\n\n#### compute target area level averages to include in the model\ncandidate_vars &lt;- survey_dt |&gt;\n  select(any_of(candidate_vars), contains(\"_X_\")) |&gt;\n  names()\n\nsurvey_dt &lt;- \n  survey_dt |&gt; \n  group_by(district) |&gt; \n  mutate(\n    across(\n      any_of(candidate_vars),\n      ~ weighted.mean(x = ., w = weight, na.rm = TRUE), \n      .names = \"{.col}_targetmean\"\n    )\n  ) |&gt; \n  ungroup()\n\ncensus_dt &lt;-\n  census_dt |&gt; \n  group_by(district) |&gt; \n  mutate(\n    across(\n      any_of(candidate_vars),\n      ~ weighted.mean(x = ., na.rm = TRUE), \n      .names = \"{.col}_targetmean\"\n    )\n  ) |&gt; \n  ungroup()\n\n#### create regional dummies\nsurvey_dt &lt;-\n  survey_dt |&gt;\n  mutate(dummy = 1, state2 = state) |&gt;\n  pivot_wider(names_from = state2,\n              names_prefix = \"state_\",\n              values_from = dummy,\n              values_fill = 0) |&gt;\n  rename_with(~ str_replace(., \" \", \"\"), starts_with(\"state_\")) \n\ncensus_dt &lt;-\n  census_dt |&gt;\n  mutate(dummy = 1, state2 = state) |&gt;\n  pivot_wider(names_from = state2,\n              names_prefix = \"state_\",\n              values_from = dummy,\n              values_fill = 0) |&gt;\n  rename_with(~ str_replace(., \" \", \"\"), starts_with(\"state_\"))\n\n#### lets update the set of candidate variables\ncandidate_vars &lt;- survey_dt |&gt; \n  select(any_of(candidate_vars), contains(\"state_\")) |&gt; \n  names()\n\nIn rear cases, it should be noted that dummy variables with too few observations in any class might introduce high multicollinearity or reduce the degrees of freedom.\n\n\n3.3.3 Final Preparations for Variable Selection\nCertain diagnostics checks ought to be performed before the variable selection process is implemented. First, we check the distribution of the non-transformed outcome variable. In the case of income or household consumption, it is typically expected and preferred that the income/household consumption variable can be transformed into a normally distributed random variable. We apply the log and boxcox transformations as seen in the code below:\n\n#### let's create the set of outcome variables for the different potential\n#### income transformations we might be interested in doing\n\n###### log transformation\nsurvey_dt &lt;- \n  survey_dt |&gt;\n  mutate(logeqIncome = log(eqIncome))\n\n###### boxcox transformation\n#### apply box-cox transformation\nboxcox_result &lt;- MASS::boxcox(lm(eqIncome ~ 1, data = survey_dt), \n                              lambda = seq(-2, 2, by = 0.1))\n\nlambda_opt &lt;- boxcox_result$x[which.max(boxcox_result$y)]\ncat(\"Optimal Lambda:\", lambda_opt, \"\\n\")\n\nOptimal Lambda: 0.3030303 \n\n## Apply the transformation manually\nif (lambda_opt == 0) {\n  survey_dt &lt;-\n    survey_dt |&gt;\n    mutate(bcxeqIncome = log(eqIncome))\n  \n} else {\n  survey_dt &lt;-\n    survey_dt |&gt;\n    mutate(bcxeqIncome = (eqIncome^lambda_opt - 1) / lambda_opt)\n  \n}\n\n#### compare the distributions of the outcome variables created\np1 &lt;-\n  survey_dt |&gt;\n  ggplot() +\n  geom_histogram(\n    aes(x = logeqIncome),\n    binwidth = 0.5,\n    fill = \"blue\",\n    color = \"black\"\n  ) +\n  labs(title = \"Log Income Distribution\") +\n  theme_minimal()\n\np2 &lt;-\n  survey_dt |&gt;\n  ggplot() +\n  geom_histogram(\n    aes(x = bcxeqIncome),\n    binwidth = 0.5,\n    fill = \"red\",\n    color = \"black\"\n  ) +\n  labs(title = \"Box-Cox Income Distribution\") +\n  theme_minimal()\n\np1 + p2\n\n\n\n\n\n\n\nFigure 3.1\n\n\n\n\n\n\n\n\n\n\n\nFigure 3.2\n\n\n\n\n\nSeveral other transformations are also possible including the ordernorm transformation. See bestNormalize::orderNorm() documentation for more details.\nNext, we ensure the candidate variables in the survey and census come from similar distributions. One assumption of the linear mixed effects approach is that the variables selected are drawn from the same distribution.\nIn the following chunk, we apply the povmap::ebp_test_means() function to present a table of means for each survey and census and show the results of the standard z-tests. It is common to drop values that reject the null hypothesis (at the 95% level) that the survey variable (for any given variable) has a different mean from the same variable in the census.\n\ntest_dt &lt;- povmap::ebp_test_means(varlist = candidate_vars,\n                                  smp_data = survey_dt,\n                                  pop_data = census_dt,\n                                  weights = \"weight\")\ntest_dt |&gt; flextable() |&gt; colformat_double(big.mark = \"\", digits = 3)\n\n\n\nTable 3.1\n\n\n\nvariablesmp_meanspop_meansdiffpvalueage_ben5478.6105304.057-174.5530.990age_ben_X_gender2550.1852369.536-180.6490.984cap_inv487.266456.851-30.4140.994cap_inv_X_gender215.913205.825-10.0880.997cash12712.23312706.449-5.7841.000cash_X_gender2982.1243379.769397.6450.972dis_ben523.440542.32618.8850.997dis_ben_X_gender227.350257.05729.7070.991eqsize1.6101.603-0.0070.994eqsize_X_gender0.5090.5390.0300.977fam_allow1617.4881624.9587.4700.999fam_allow_X_gender442.459506.06863.6090.983gender0.3720.3910.0190.978house_allow61.82065.4143.5940.995house_allow_X_gender26.14923.319-2.8300.993rent608.004770.358162.3530.986rent_X_gender184.389387.367202.9780.973self_empl2039.1251966.965-72.1600.995self_empl_X_gender413.684495.88582.2010.987sick_ben61.83767.4515.6140.996sick_ben_X_gender31.42321.924-9.4990.987state_Burgenland0.0130.0320.0190.929state_Carinthia0.0680.0690.0010.999state_LowerAustria0.1660.1850.0190.972state_Salzburg0.0700.067-0.0030.993state_Styria0.1440.135-0.0080.987state_Tyrol0.0730.0760.0020.995state_UpperAustria0.1680.163-0.0050.992state_Vienna0.2550.234-0.0200.974state_Vorarlberg0.0430.039-0.0030.990surv_ben61.91888.95227.0350.984surv_ben_X_gender24.14244.82120.6790.982tax_adj-76.558-82.540-5.9820.998tax_adj_X_gender-18.444-31.138-12.6940.994unempl_ben463.508429.382-34.1260.990unempl_ben_X_gender207.672178.941-28.7300.987\n\n\n\n\n\nHowever, the ebp_test_means function doesn’t control for the fact that the variables are national representative at the state level. We implement another variant to the ebp_test_means that will allow users to cluster the standard errors at the state level.\n\n#' Perform test for difference between survey and census means \n#' \n#' This function computes weighted means of the same set of variables within the census and survey controlling for a cluster level. A test for \n#' difference of the means are performed for each variable with two-tailed p-values returned and the cluster level has to be specified for the\n#' estimation of variance\n#' \n#' @param varlist character vector, the set of variables of interest\n#' @param smp_data the survey data\n#' @param pop_data the population data\n#' @param weights a character string containing the name of a variable that indicates weights in the sample data. If a character string is \n#' provided a weighted version of the ebp will be used.\n#' @param pop_weights a character string containing the name of a variable that indicates population weights in the population data. If a \n#' If a character string is provided weighted indicators are estimated using population weights. The variable has to be numeric. \n#' Defaults to NULL. \n#' \n#' @import survey\n\n\nebp_test_means_clustered &lt;- function(varlist, \n                                     smp_data, \n                                     pop_data, \n                                     cluster, \n                                     weights = NULL, \n                                     pop_weights = NULL) {\n  \n  if (is.null(weights)) {\n    smp_data$weights &lt;- rep(1, nrow(smp_data))\n    weights &lt;- \"weights\"\n  }\n  if (is.null(pop_weights)) {\n    pop_data$pop_weights &lt;- rep(1, nrow(pop_data))\n    pop_weights &lt;- \"pop_weights\"\n  } else {\n    \n    pop_data$pop_weights &lt;- pop_data[[pop_weights]]\n    \n  }\n  \n  smp_df &lt;- smp_data[complete.cases(smp_data[, c(varlist, weights, cluster)]), c(varlist, weights, cluster)]\n  pop_df &lt;- pop_data[complete.cases(pop_data[, c(varlist, \"pop_weights\", cluster)]), c(varlist, \"pop_weights\", cluster)]\n  \n  smp_df &lt;- smp_df |&gt; mutate(across(all_of(varlist), as.numeric))\n  pop_df &lt;- pop_df |&gt; mutate(across(all_of(varlist), as.numeric))\n  \n  # Define survey design with clustering\n  smp_design &lt;- svydesign(id = ~get(cluster), weights = ~get(weights), data = smp_df)\n  pop_design &lt;- svydesign(id = ~get(cluster), weights = ~pop_weights, data = pop_df)\n  \n  smp_means_df &lt;- data.frame(\n    smp_means = sapply(varlist, function(var) svymean(as.formula(paste(\"~\", var)), smp_design)[1]),\n    smp_se = sapply(varlist, function(var) SE(svymean(as.formula(paste(\"~\", var)), smp_design))),\n    variable = varlist\n  )\n  \n  pop_means_df &lt;- data.frame(\n    pop_means = sapply(varlist, function(var) svymean(as.formula(paste(\"~\", var)), pop_design)[1]),\n    pop_se = sapply(varlist, function(var) SE(svymean(as.formula(paste(\"~\", var)), pop_design))),\n    variable = varlist\n  )\n  \n  means_df &lt;- merge(smp_means_df, pop_means_df, by = \"variable\")\n  means_df$diff &lt;- means_df$pop_means - means_df$smp_means\n  means_df$diff_se &lt;- sqrt(means_df$smp_se^2 + means_df$pop_se^2)\n  means_df$zscore &lt;- means_df$diff / means_df$diff_se\n  means_df$pvalue &lt;- 2 * (1 - pnorm(abs(means_df$zscore)))\n  \n  return(means_df[, c(\"variable\", \"smp_means\", \"pop_means\", \"diff\", \"pvalue\")])\n  \n}\n\n\ntest_dt &lt;- \n  ebp_test_means_clustered(\n    varlist = candidate_vars,\n    smp_data = survey_dt,\n    pop_data = census_dt,\n    cluster = \"state\",\n    weights = \"weight\"\n    )\ntest_dt |&gt; flextable() |&gt; colformat_double(big.mark = \"\", digits = 3)\n\n\n\nTable 3.2\n\n\n\nvariablesmp_meanspop_meansdiffpvalueage_ben5478.6105304.057-174.5530.550age_ben_X_gender2550.1852369.536-180.6490.387cap_inv487.266456.851-30.4140.726cap_inv_X_gender215.913205.825-10.0880.829cash12712.23312706.449-5.7840.991cash_X_gender2982.1243379.769397.6450.261dis_ben523.440542.32618.8850.786dis_ben_X_gender227.350257.05729.7070.346eqsize1.6101.603-0.0070.915eqsize_X_gender0.5090.5390.0300.353fam_allow1617.4881624.9587.4700.973fam_allow_X_gender442.459506.06863.6090.210gender0.3720.3910.0190.524house_allow61.82065.4143.5940.717house_allow_X_gender26.14923.319-2.8300.763rent608.004770.358162.3530.418rent_X_gender184.389387.367202.9780.078self_empl2039.1251966.965-72.1600.728self_empl_X_gender413.684495.88582.2010.356sick_ben61.83767.4515.6140.687sick_ben_X_gender31.42321.924-9.4990.249state_Burgenland0.0130.0320.0190.626state_Carinthia0.0680.0690.0010.996state_LowerAustria0.1660.1850.0190.935state_Salzburg0.0700.067-0.0030.977state_Styria0.1440.135-0.0080.966state_Tyrol0.0730.0760.0020.985state_UpperAustria0.1680.163-0.0050.981state_Vienna0.2550.234-0.0200.946state_Vorarlberg0.0430.039-0.0030.957surv_ben61.91888.95227.0350.357surv_ben_X_gender24.14244.82120.6790.138tax_adj-76.558-82.540-5.9820.844tax_adj_X_gender-18.444-31.138-12.6940.659unempl_ben463.508429.382-34.1260.678unempl_ben_X_gender207.672178.941-28.7300.514\n\n\n\n\n\nIn the next section, we fold the final checks into the variable selection process. We drop variables that are highly correlated and set a sparsity threshold. The sparsity threshold ensures that variables that do not have a certain proportion of non-missing observations are dropped. We have folded both these checks into the glmnetlasso_vselect() function.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unit-Level Models</span>"
    ]
  },
  {
    "objectID": "ul.html#the-variable-selection-process",
    "href": "ul.html#the-variable-selection-process",
    "title": "3  Unit-Level Models",
    "section": "3.4 The Variable Selection Process",
    "text": "3.4 The Variable Selection Process\nThe glmnetlasso_vselect() function takes the dependent variable (welfare or income variable) as well as the set of potential candidate variables which just created and applies the lasso methodology (run here(glmnet::glmnet) for more details). This includes the option to perform a reproducible n-fold cross validation to reduce the risk of overfitting the model. In this instance, we have run applied this function to select the best predictors of household welfare based on the 3 welfare transformations i.e. 3 separate runs of the function, one for each transformation. See below:\n\n#' A function for variable selection using the GLMNET R package\n#' \n#' This function acts as a wrapper to the GLMNET R package which performs variable selection with nfold cross validation. \n#' \n#' @details This function cleans the data `dt` first by standardizing the predictors, dropping columns with missing values, very low variance (near\n#' zero variance), highly correlated variables based on a certain `correlation_threshold`. The function also drops variables with an high percentage #' of zeros based on a `sparsity_threshold`. It then fits the lasso regression with the GLMNET package before returning the best combination of\n#' predictive variables based on the `lambda_type` selection criteria. \n#' \n#' \n#' @param dt data.frame or data.table\n#' @param candidate_vars character, the set of potential predictors within `dt`\n#' @param y character, the variable name of the outcome variable within `dt`\n#' @param weights character, weight variable name\n#' @param alpha integer, 1 for LASSO and 0 for ridge regression\n#' @param nfolds integer, the number of cross fold validations to perform\n#' @param seed integer, randomization seed \n#' @param lambda_type, either \"lambda.min\" or \"lambda.1se\". see `glmnet::glmnet()` for more information\n#' @param correlation_threshold numeric, the threshold for dropping correlated variables (value between 0 and 1)\n#' @param variance_threshold numeric, threshold for dropping variables that appear almost constant by specifying a minimum variance that must be met\n#' @param sparsity_threshold numeric, threshold for dropping sparse variables\n#' \n#' @export\n#' \n#' @import glmnet \n#' @importFrom caret findCorrelation\n\nglmnetlasso_vselect &lt;- function(dt, \n                                candidate_vars, \n                                y, \n                                weights, \n                                alpha = 1, \n                                nfolds, \n                                seed = 123,\n                                lambda_type = \"lambda.min\",\n                                correlation_threshold = 0.9, # Threshold for dropping correlated variables\n                                variance_threshold = 1e-4,\n                                sparsity_threshold = 0.99,# Threshold for dropping sparse variables\n                                ...) {\n  # Load necessary library\n  if (!requireNamespace(\"glmnet\", quietly = TRUE)) {\n    stop(\"The glmnet package is required. Please install it.\")\n  }\n  \n  if (!requireNamespace(\"caret\", quietly = TRUE)) {\n    install.packages(\"caret\")\n  }\n  \n  # Ensure reproducibility\n  set.seed(seed)\n  \n  # Standardize predictors\n  X_scaled &lt;- scale(dt[, candidate_vars])\n  y &lt;- dt[[y]]\n  weights &lt;- dt[[weights]]\n  \n  # Drop any columns with missing values in X_scaled\n  X_scaled &lt;- X_scaled[, colSums(is.na(X_scaled)) == 0]\n  \n  # Drop variables with very low variance\n  variances &lt;- apply(X_scaled, 2, var)\n  X_scaled &lt;- X_scaled[, variances &gt; variance_threshold]\n  \n  # Drop highly correlated variables\n  correlation_matrix &lt;- cor(X_scaled)\n  high_corr &lt;- caret::findCorrelation(correlation_matrix, \n                                      cutoff = correlation_threshold, \n                                      verbose = FALSE)\n  if (length(high_corr) &gt; 0) {\n    X_scaled &lt;- X_scaled[, -high_corr]\n  }\n  \n  # Identify and drop variables with 99% or more zeros\n  # Calculate proportion of zeros for each column\n  proportion_zeros &lt;- colMeans(X_scaled == 0)\n  \n  # Filter out columns where proportion of zeros is above the threshold\n  X_scaled &lt;- X_scaled[, proportion_zeros &lt; sparsity_threshold]\n  \n  # Check for problematic values\n  if (anyNA(X_scaled) || any(is.infinite(X_scaled)) || any(is.nan(X_scaled))) {\n    stop(\"Predictor matrix contains NA, Inf, or NaN values.\")\n  }\n  if (any(weights &lt;= 0)) {\n    stop(\"Weights contain non-positive values.\")\n  }\n\n  # Fit lasso model with cross-validation\n  cv_model &lt;- glmnet::cv.glmnet(\n    x = X_scaled,\n    y = y,\n    weights = weights,\n    alpha = alpha,  # alpha = 1 for lasso, 0 &lt; alpha &lt; 1 for elastic net\n    nfolds = nfolds,\n    family = \"gaussian\", # Change to \"binomial\" or \"poisson\" for other models\n    ...\n  )\n  \n  # Extract coefficients at the lambda with minimum cross-validated error\n  selected_model &lt;- glmnet::glmnet(\n    x = X_scaled,\n    y = y,\n    weights = weights,\n    alpha = alpha,\n    lambda = cv_model[[lambda_type]],\n    family = \"gaussian\",\n    ...\n  )\n  \n  # Identify selected variables\n  selected_variables &lt;- rownames(as.matrix(coef(selected_model)))[as.matrix(coef(selected_model)) != 0]\n  selected_variables &lt;- selected_variables[selected_variables != \"(Intercept)\"]\n  \n  return(selected_variables)\n  \n}\n\n\n\n#### lets call this function to model selection for each transformation\nnotglmnet_list &lt;- \n  glmnetlasso_vselect(dt = survey_dt,\n                      candidate_vars = candidate_vars,\n                      y = \"eqIncome\",\n                      weights = \"weight\",\n                      nfolds = 10,\n                      seed = 123,\n                      lambda_type = \"lambda.1se\",\n                      sparsity_threshold = 0.99)\n \n\nlogglmnet_list &lt;- \n  glmnetlasso_vselect(dt = survey_dt,\n                      candidate_vars = candidate_vars,\n                      y = \"logeqIncome\",\n                      weights = \"weight\",\n                      nfolds = 10,\n                      seed = 123,\n                      lambda_type = \"lambda.1se\",\n                      sparsity_threshold = 0.99)\n \nbcxglmnet_list &lt;- \n  glmnetlasso_vselect(dt = survey_dt,\n                      candidate_vars = candidate_vars,\n                      y = \"bcxeqIncome\",\n                      weights = \"weight\",\n                      nfolds = 10,\n                      seed = 123,\n                      lambda_type = \"lambda.1se\",\n                      sparsity_threshold = 0.99)\n\nNow that we have selected variables for each outcome variable transformation. We are ready to apply this povmap::ebp() to estimate a poverty map for Austria. The function will estimate a linear mixed effects model of the income in Austria from which the poverty line will be applied to estimate the poverty rates. Please run help(povmap::ebp) for details about the structure of the resulting object produced.\nFor the proper functioning of the povmap::ebp function, the following conditions must be met:\n\nthe arguments pop_data and smp_data require the survey and census datasets must be of class data.frame.\npop_data and smp_data must contain no missing observations across all the variables. Use the na.omit() function to ensure only complete cases are included within each object.\nAll target areas (or domains) within the smp_domains must be found within pop_domains i.e. for the Austria example, all domains/target areas in the survey must be found in the census.\nrescale_weights argument set to TRUE may solve parameter estimation convergence issues. This is not available within the emdi::ebp() function.\nNotice the specification of the Ydump argument. This is one difference between the emdi::ebp() and povmap::ebp(). This argument returns the result of L unit-level welfare simulated predictions from which other poverty estimations maybe carried out, as different from the default results present within ebp class object returned by ebp().\nAlso noteworthy, is the use of the weight_type argument present within the povmap::ebp() but not in the emdi::ebp(). Please see documentation for more details.\n\n\nfldr_temp &lt;- \"data-temp\"\nfile.path(fldr_temp, \"Ydump\") |&gt; dir.create(recursive = T, showWarnings = F)\n\n\n# using the ebp function to first estimate into the household survey. \n# We need to see how well the model will estimate poverty first into \n# the training set i.e. the household survey. this helps to check the\n# quality of in-sample estimation without any potential prediction bias\n\nmodel_formula &lt;-\n  paste0(\"eqIncome ~ \", paste(logglmnet_list, collapse = \" + \")) |&gt;\n  as.formula()\n\nlog_smodel &lt;-\n  povmap::ebp(\n    fixed = model_formula,\n    pop_data = survey_dt[, c(logglmnet_list, \"district\")],\n    pop_domains = \"district\",\n    smp_data = survey_dt[, c(\"eqIncome\", logglmnet_list, \"district\", \"weight\")],\n    smp_domains = \"district\",\n    MSE = TRUE,\n    threshold = 18207.2,\n    transformation = \"log\",\n    B = 50,\n    L = 50,\n    weights = \"weight\",\n    rescale_weights = TRUE,\n    Ydump = file.path(fldr_temp, \"Ydump/unitsurvey_logYdump_glmnet.csv\"),\n    cpus = 30\n  )\nsaveRDS(log_smodel, file.path(fldr_temp, \"log_surveymodel.RDS\"))\n\nmodel_formula &lt;-\n  paste0(\"eqIncome ~ \", paste(bcxglmnet_list, collapse = \" + \")) |&gt; \n  as.formula()\n\n\nbcx_smodel &lt;-\n  povmap::ebp(\n    fixed = model_formula,\n    pop_data = survey_dt[, c(bcxglmnet_list, \"district\")],\n    pop_domains = \"district\",\n    smp_data = survey_dt[, c(bcxglmnet_list, \"district\", \"eqIncome\", \"weight\")],\n    smp_domains = \"district\",\n    MSE = TRUE,\n    threshold = 18207.2,\n    transformation = \"box.cox\",\n    B = 50,\n    L = 50,\n    weights = \"weight\",\n    rescale_weights = TRUE,\n    Ydump = file.path(fldr_temp, \"Ydump/unitsurvey_bcxYdump_glmnet.csv\"),\n    cpus = 30,\n    weights_type = \"nlme_lambda\"\n  )\nsaveRDS(bcx_smodel, file.path(fldr_temp, \"bcx_surveymodel.RDS\"))\n\n\nmodel_formula &lt;- \n  paste0(\"eqIncome ~ \", paste(notglmnet_list, collapse = \" + \")) |&gt; \n  as.formula()\n\nnot_smodel &lt;-\n  povmap::ebp(\n    fixed = model_formula,\n    pop_data = survey_dt[, c(notglmnet_list, \"district\")],\n    pop_domains = \"district\",\n    smp_data = survey_dt[, c(notglmnet_list, \"district\", \"eqIncome\", \"weight\")],\n    smp_domains = \"district\",\n    MSE = TRUE,\n    threshold = 18207.2,\n    transformation = \"no\",\n    B = 50,\n    L = 50,\n    weights = \"weight\",\n    rescale_weights = TRUE,\n    Ydump = \"data/Ydump/unitsurvey_notYdump_glmnet.csv\",\n    cpus = 30\n  )\n\nsaveRDS(not_smodel, file.path(fldr_temp, \"not_surveymodel.RDS\"))\n\n### then we actually estimate the census level estimation\nmodel_formula &lt;- \n  paste0(\"eqIncome ~ \", paste(logglmnet_list, collapse = \" + \")) |&gt;\n  as.formula()\n\nlog_model &lt;-\n  povmap::ebp(\n    fixed = model_formula,\n    pop_data = census_dt[, c(logglmnet_list, \"district\")],\n    pop_domains = \"district\",\n    smp_data = survey_dt[, c(\"eqIncome\", logglmnet_list, \"district\", \"weight\")],\n    smp_domains = \"district\",\n    MSE = TRUE,\n    threshold = 18207.2,\n    transformation = \"log\",\n    B = 50,\n    L = 50,\n    weights = \"weight\",\n    rescale_weights = TRUE,\n    Ydump = file.path(fldr_temp, \"Ydump/unitcensus_logYdump_glmnet.csv\"),\n    cpus = 30\n  )\nsaveRDS(log_model, file.path(fldr_temp, \"log_censusmodel.RDS\"))\n\nmodel_formula &lt;-\n  paste0(\"eqIncome ~ \", paste(bcxglmnet_list, collapse = \" + \")) |&gt;\n  as.formula()\n\nbcx_model &lt;-\n  povmap::ebp(\n    fixed = model_formula,\n    pop_data = census_dt[, c(bcxglmnet_list, \"district\")],\n    pop_domains = \"district\",\n    smp_data = survey_dt[, c(bcxglmnet_list, \"district\", \"eqIncome\", \"weight\")],\n    smp_domains = \"district\",\n    MSE = TRUE,\n    threshold = 18207.2,\n    transformation = \"box.cox\",\n    B = 50,\n    L = 50,\n    weights = \"weight\",\n    rescale_weights = TRUE,\n    Ydump = file.path(fldr_temp, \"data/Ydump/unitcensus_bcxYdump_glmnet.csv\"),\n    cpus = 30,\n    weights_type = \"nlme_lambda\"\n  )\n\nsaveRDS(bcx_model, file.path(fldr_temp, \"bcx_censusmodel.RDS\"))\n\nmodel_formula &lt;- \n  paste0(\"eqIncome ~ \", paste(notglmnet_list, collapse = \" + \")) |&gt; \n  as.formula()\n\nnot_model &lt;-\n  povmap::ebp(\n    fixed = model_formula,\n    pop_data = census_dt[, c(notglmnet_list, \"district\")],\n    pop_domains = \"district\",\n    smp_data = survey_dt[, c(notglmnet_list, \"district\", \"eqIncome\", \"weight\")],\n    smp_domains = \"district\",\n    MSE = TRUE,\n    threshold = 18207.2,\n    transformation = \"no\",\n    B = 50,\n    L = 50,\n    weights = \"weight\",\n    rescale_weights = TRUE,\n    Ydump = file.path(fldr_temp, \"Ydump/unitcensus_notYdump_glmnet.csv\"),\n    cpus = 30\n  )\n\nsaveRDS(not_model, file.path(fldr_temp, \"data/not_censusmodel.RDS\"))\n\n\nlog_smodel &lt;- readRDS(file.path(fldr_temp, \"log_surveymodel.RDS\"))\nbcx_smodel &lt;- readRDS(file.path(fldr_temp, \"bcx_surveymodel.RDS\"))\nnot_smodel &lt;- readRDS(file.path(fldr_temp, \"not_surveymodel.RDS\"))\nlog_model &lt;- readRDS(file.path(fldr_temp, \"log_censusmodel.RDS\"))\nbcx_model &lt;- readRDS(file.path(fldr_temp, \"bcx_censusmodel.RDS\"))\nnot_model &lt;- readRDS(file.path(fldr_temp, \"not_censusmodel.RDS\"))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unit-Level Models</span>"
    ]
  },
  {
    "objectID": "ul.html#post-estimation-diagnostics",
    "href": "ul.html#post-estimation-diagnostics",
    "title": "3  Unit-Level Models",
    "section": "3.5 Post Estimation Diagnostics",
    "text": "3.5 Post Estimation Diagnostics\nOnce the model has been estimated. It is essential to test the validity of the model based on the model assumptions. Below are the set of typical tests which we will perform:\n\n3.5.1 Checking the quality of in-sample prediction\n\n3.5.1.1 Aggregate Poverty Rates at the lowest level of National Representativeness for EBP vs Direct Poverty Rates\nThe first test is to ensure the model is able to replicate the welfare distribution within the same survey. If this test fails, there is no reason to expect our model to provide unbiased estimates out of sample. We run the function ebp_national_pov() below to compare estimated poverty rates aggregated to the state level to the direct estimates from the survey. We apply the function to each model. Ideally, we want the estimated state poverty rates to be as close as possible to the direct estimates at the same level (typically within the 95% confidence level).\n\n#### first let us look at the quality of in-sample prediction\n\n#' A function to estimate poverty rates in levels different from the target area\n#' \n#' This function will take the ebp object (result of ebp()) as well as the population data to estimate \n#' poverty rates at a level different from the designated target area level stipulated for poverty \n#' mapping in the `ebp()` function. \n#' \n#' @param ebp_obj object of class `\"ebp\" \"emdi\"`\n#' @param wgt_var chr, the weight variable name \n#' @param pop_domain chr, the population domain used for `ebp()`\n#' @param est_domain chr, the estimation domain\n#' @param pop_dt data.frame, the population dataset/census\n#' @param indicators chr, a character or vector of characters for the indicators of interest\n#' \n#' @import data.table dplyr\n\nebp_national_pov &lt;- function(ebp_obj,\n                             wgt_var,\n                             pop_domain,\n                             est_domain,\n                             pop_dt,\n                             indicators = c(\"Head_Count\")) {\n  \n  \n  pop_dt &lt;- \n    pop_dt |&gt;\n    group_by(!!sym(pop_domain), !!sym(est_domain)) |&gt;\n    summarise(population = sum(!!sym(wgt_var), na.rm = TRUE), .groups = \"drop\")\n  \n  # Merge the ebp object data with population data\n  dt &lt;- merge(ebp_obj$ind, \n              pop_dt[, c(pop_domain, \"population\", est_domain)], \n              by.x = \"Domain\", \n              by.y = pop_domain, \n              all.x = TRUE)\n  \n  # Compute weighted means for all indicators\n  \n  pov_dt &lt;- \n    dt %&gt;%\n    as.data.table() %&gt;%\n    .[, lapply(.SD, weighted.mean, w = population, na.rm = TRUE),\n      .SDcols = indicators,\n      by = est_domain]\n\n  return(pov_dt)\n  \n}\n\n\nebpsurveypov_dt &lt;- lapply(\n  X = list(not_smodel, bcx_smodel, log_smodel),\n  FUN = function(ebp_obj) {\n    z &lt;- ebp_national_pov(\n      ebp_obj = ebp_obj,\n      wgt_var = \"weight\",\n      pop_domain = \"district\",\n      pop_dt = survey_dt,\n      est_domain = \"state\"\n    )\n    return(z)\n  }\n)\n\n### rename headcount columns appropriately\nebpsurveypov_dt &lt;-\n  mapply(\n    pov_dt = ebpsurveypov_dt,\n    name_obj = c(\"not\", \"bcx\", \"log\"),\n    FUN = function(pov_dt, name_obj) {\n      pov_dt |&gt;\n        rename_with(~ paste0(name_obj, .), .cols = \"Head_Count\")\n    },\n    SIMPLIFY = FALSE\n  )\n\nebpsurveypov_dt &lt;- Reduce(f = merge,\n                          x = ebpsurveypov_dt)\n\n### we create some fake clusters within the districts to show how to \n### use the survey package to estimate the standard errors on the \n### poverty rates, ideally these would already exist within your survey\n\n#### for simplicity we will assume there are 5 clusters in each district\nsurvey_dt &lt;-\n  survey_dt %&gt;%\n  group_by(district) %&gt;%\n  mutate(num_clusters = pmax(2, round(n() / sample(5:15, 1))), \n         cluster = sample(rep(1:num_clusters, length.out = n()))) %&gt;%\n  ungroup() %&gt;%\n  mutate(cluster_id = dense_rank(interaction(district, cluster)))\n\nWarning: There were 70 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `cluster = sample(rep(1:num_clusters, length.out = n()))`.\nℹ In group 1: `district = Neusiedl am See`.\nCaused by warning in `1:num_clusters`:\n! numerical expression has 16 elements: only the first used\nℹ Run `dplyr::last_dplyr_warnings()` to see the 69 remaining warnings.\n\nsvy_obj &lt;-\n  survey_dt %&gt;%\n  mutate(poor = ifelse(eqIncome &lt; 18207.2, 1, 0)) %&gt;%\n  dplyr::select(district, weight, state, poor, cluster_id) %&gt;%\n  survey::svydesign(\n    ids = ~ cluster_id,\n    weights = ~ weight,\n    strata = ~ state,\n    survey.lonely.psu = \"adjust\",\n    data = .\n  )\n\nvar_dt &lt;-\n  svyby(~ poor, ~ state, svy_obj, svymean) %&gt;%\n  mutate(poorLB = poor - 1.96 * se, poorUB = poor + 1.96 * se)\n\nebpsurveypov_dt &lt;-\n  ebpsurveypov_dt |&gt; \n  left_join(\n    var_dt |&gt; select(any_of(c(\"state\", \"poor\", \"poorLB\", \"poorUB\"))),\n    join_by(\"state\")\n  )\n\n\n3.5.1.1.1 Compare Survey EBP Poverty Rates to Direct Poverty Rates at different poverty lines\nAnother check for the quality of prediction within the survey is testing the predictive power of the model at different poverty lines along the entire income distribution. In the example below, we show compare the predicted poverty rate to the direct poverty rate using each 5th percentile increment in income i.e. using poverty ventile. We implement a function compare_surveyebp_atpovline() which computes poverty from the simulated welfare data (produced by Ydump argument in ebp()) and the survey at each poverty line. The function allows the user specify the percentiles at which poverty lines will be specified. The default is set at every 5th percentile (seq(0, 1, 0.05)).\nWe apply compare_surveyebp_at_povline() to each of the estimated models in comparison with the direct survey estimates at poverty line ventiles (every 5th percentile).\n\n### first let's read in the data ydump data\nydumppath_list &lt;- list.files(\n  path = file.path(fldr_temp, \"Ydump\"),\n  pattern = \"^unitsurvey_.*Ydump_glmnet.csv\",\n  full.names = TRUE\n)\n\n### the following code will read in the Ydump data into a list of \n###    data.frame objects and sequentially: \n### - combine the ydump with household survey\n### - compute poverty rates at each threshold\n\n#### lets write a function to do this for one of our models\nydump_dtlist &lt;- lapply(X = ydumppath_list, FUN = fread)\n\nnames(ydump_dtlist) &lt;-\n  basename(ydumppath_list) %&gt;%\n  sub(pattern = \"^unitsurvey_\", replacement = \"\") %&gt;%\n  sub(pattern = \"_glmnet.csv\", replacement = \"\")\n\n\n### a simple function to carry out the poverty rate comparisons (model vs actual at each poverty ventile, 5% increments) & plot the result\n\n\n#' Compute direct poverty rates and simulated outcome variables at specified poverty lines\n#' \n#' The function uses the simulated outcome from `povmap::ebp()`'s `Ydump` argument and the survey data to compute estimated and direct poverty    \n#' rates at a specified level than is estimated with `ebp()` at different poverty lines. \n#' \n#' @param ydump_data data.frame, the simulated welfare/income data from non-null `Ydump` argument within the `povmap::ebp()`\n#' @param smp_data data.frame, the survey data\n#' @param smp_domains character, a variable name for the domain/geographic level at which poverty rates will be estimated\n#' @param smp_weights character, the weight variable\n#' @param pline_increment numeric vector, a set of percentiles at which poverty rates should be estimated. \n#' \n#' @import data.table dplyr\n#' \n#' @export\n#' \ncompare_surveyebp_atpovline &lt;- function(ydump_data,\n                                        smp_data,\n                                        smp_domains,\n                                        smp_weights,\n                                        outcome_var,\n                                        pline_increment = seq(0, 1, 0.05)){\n  \n  ydump_dt &lt;- as.data.table(ydump_data)\n  smp_dt &lt;- as.data.table(smp_data[, c(smp_domains, smp_weights, outcome_var)])\n  \n  ydump_dt &lt;- cbind(ydump_dt, \n                    smp_dt[, c(smp_domains, smp_weights), with = FALSE] %&gt;%\n                      arrange(smp_domains))\n  \n  threshold_list &lt;-\n    wtd.quantile(x = smp_dt[[outcome_var]],\n                 weights = smp_dt[[smp_weights]],\n                 probs = pline_increment)\n  \n  compute_ptile_pov &lt;- function(welfare_dt,\n                                weights,\n                                welfare,\n                                thresholds){\n  \n    pov_list &lt;- \n    lapply(X = thresholds,\n           FUN = function(x){\n             \n             yy &lt;- \n               welfare_dt %&gt;%\n               mutate(poor = ifelse(!!sym(welfare) &lt; x, 1, 0)) %&gt;%\n               summarize(prate = weighted.mean(x = poor,\n                                               w = !!sym(weights),\n                                               na.rm = TRUE))\n             \n             return(yy)\n             \n           })\n    \n    pov_list &lt;- \n      unlist(pov_list) %&gt;%\n      data.frame() %&gt;%\n      setNames(\"pov\")\n    \n    \n    return(pov_list)\n    \n  }\n  \n  pov_dt &lt;- compute_ptile_pov(welfare_dt = ydump_dt,\n                              weights = smp_weights,\n                              welfare = \"Simulated_Y\",\n                              thresholds = threshold_list)\n  \n  pov_dt &lt;- data.table(ebp_poverty = pov_dt,\n                       probs = as.character(seq(0, 1, 0.05)))\n\n  \n  # povcheck_plots &lt;- \n  #   pov_dt %&gt;%\n  #   mutate(y )\n  #   ggplot(aes(x = as.numeric(probs)))\n  \n  return(pov_dt)\n  \n}\n\n### now lets plot the results\nsvyplinecomp_list &lt;-\n  lapply(\n    X = ydump_dtlist,\n    FUN = function(ydump) {\n      compare_surveyebp_atpovline(\n        ydump_data = ydump,\n        smp_data = survey_dt,\n        smp_domains = \"district\",\n        smp_weights = \"weight\",\n        outcome_var = \"eqIncome\"\n      )\n    }\n  )\n\n## a bit of cleaning and then making the plots\n\n\nsvyplinecomp_dt &lt;-\n  mapply(\n    comp_dt = svyplinecomp_list,\n    name_list = names(svyplinecomp_list),\n    FUN = function(comp_dt, name_list) {\n      comp_dt %&gt;%\n        rename(ebp = \"ebp_poverty.pov\") %&gt;%\n        mutate(probs = as.numeric(probs)) %&gt;%\n        mutate(diff = abs(ebp - probs) / probs) %&gt;%\n        mutate(transformation = sub(\"Ydump\", \"\", name_list))\n      \n    },\n    SIMPLIFY = FALSE\n  ) |&gt; \n  bind_rows()\n\nWe plot the absolute value of the percent difference between both poverty rates at each ventile as seen in the plot below.\n\nsvyplinecomp_dt %&gt;%\n  ggplot() +\n  geom_line(aes(x = probs,\n                y = diff,\n                color = transformation)) + \n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n3.5.1.2 Evaluating the Standard Normality Assumptions\n\nPresenting the regression table estimates (use povmap::ebp_reportcoef_table() and then translate into a flextable which can be rendered in Word, PDF or HTML)\nChecking that all model assumptions hold (normality assumptions for the miu and epsilon terms), using povmap::ebp_normalityfit() to present skewness and kurtosis for both errors. Then show a function that uses ebp object to plot the distribution of the errors and compute the kolmogrov-smirnov test statistics. We can also include the shapiro-wilks which will break down for larger sample sizes but is equally well known. Another function that produces q-q plots for miu and epsilon terms from ebp object.\nCheck on model validity: Create a plot to show how poverty rates vary at each ventile i.e. at 5% poverty line increments. This is to show how to check the quality of model prediction without the added bias of out of sample prediction\nComputing MSE and CVs and computing the statistical gains made from performing small area estimation i.e. in practical terms, how much bigger would the survey have to be the get the same level of precision that SAE now gives us with the census data.\nFinal validation: EBP estimates vs Direct Estimates (supposedly truth) at the highest resolution level that is considered nationally representative, this is usually the regional level in Africa.\nPlotting the poverty map using the ebp object and the shapefile\n\n\n#### presenting the results of the linear mixed effects regression\nspecify_decimal &lt;- function(x, k) trimws(format(round(x, k), nsmall=k))\n\n### to quickly create coefficients table\ncoef_dt &lt;- povmap::ebp_reportcoef_table(log_model) \n\n## showing how to present the skewness and kurtosis of the random effects \n##   and model errors\nerr_dt &lt;-\n  povmap::ebp_normalityfit(log_model) %&gt;%\n  mutate(value = specify_decimal(value, 3))\n\n### to convert this into a publication ready report\ncreate_regression_table &lt;- function(coef_table, eval_table) {\n  \n  # Rename columns for consistency\n  coef_table &lt;- \n    coef_table %&gt;%\n    rename(Description = Variable,\n           Estimate = coeff, \n           `Std. Error` = std_error) %&gt;%\n    mutate(Type = \"Coefficients\") %&gt;%\n    \n    # Format std. error under estimates\n    mutate(Estimate = paste0(Estimate, \"\\n(\", `Std. Error`, \")\")) %&gt;%  \n    dplyr::select(Type, Description, Estimate)\n\n  eval_table &lt;- eval_table %&gt;%\n    rename(Description = indicator, Estimate = value) %&gt;%\n    mutate(Type = \"Diagnostics\")\n\n  # Combine coefficient and diagnostic tables\n  full_table &lt;- rbind(coef_table, \n                      eval_table %&gt;%\n                        dplyr::select(colnames(coef_table)))\n\n  # Identify where diagnostics start\n  diag_start &lt;- nrow(coef_table) + 1\n\n  # Create flextable\n  regression_table &lt;- \n  flextable(full_table) %&gt;%\n    set_header_labels(\n      Type = \"Type\",\n      Description = \"Description\",\n      Estimate = \"Estimate\"\n    ) %&gt;%\n    hline(part = \"all\") %&gt;%\n    merge_v(j = \"Type\") %&gt;%\n    align(j = \"Description\", align = \"left\", part = \"all\") %&gt;%\n    align(j = \"Estimate\", align = \"center\", part = \"all\") %&gt;%\n    vline(j = 1, border = fp_border(color = \"black\", width = 1)) %&gt;%\n    hline(i = diag_start - 1, border = fp_border(color = \"black\", width = 1)) %&gt;%\n    autofit() %&gt;%\n    width(j = \"Type\", width = 1.2) %&gt;%\n    width(j = \"Description\", width = 2) %&gt;%\n    width(j = \"Estimate\", width = 1.5)\n\n  # Styling for diagnostics\n  regression_table &lt;- regression_table %&gt;%\n    bold(i = diag_start:nrow(full_table), bold = TRUE) %&gt;%\n    italic(i = diag_start:nrow(full_table), italic = TRUE) %&gt;%\n    font(fontname = \"Times New Roman\", part = \"all\") %&gt;%\n    fontsize(size = 10, part = \"all\")\n\n  return(regression_table)\n  \n}\n\n### regression tables\ncreate_regression_table(coef_table = coef_dt,\n                        eval_table = err_dt)\n\nTypeDescriptionEstimateCoefficients(Intercept)9.161***(0.032)eqsize-0.043***(0.013)cash0.00003***(0.0000008)self_empl0.000022***(0.000001)unempl_ben0.000021***(0.0000038)age_ben0.00003***(0.0000011)surv_ben0.000032***(0.0000078)sick_ben0.000028**(0.00001)dis_ben0.000036***(0.0000025)rent0.000013***(0.0000014)house_allow0.000051**(0.000021)cap_inv0.000015***(0.0000027)tax_adj-0.000014**(0.0000043)cash_X_gender0.0000047***(0.000001)self_empl_X_gender0.0000082***(0.0000023)age_ben_X_gender0.0000022(0.0000014)rent_X_gender0.0000055**(0.0000025)cap_inv_X_gender0.0000078(0.0000043)Diagnosticsrsq_marginal0.518rsq_conditional0.601epsilon_skewness-2.213epsilon_kurtosis18.270random_skewness-0.721random_kurtosis3.508\n\n\n\n### start by explaining that the plot function could be used in R \n###  to show the error diagnostics as follows\n# plot(log_model, whitch = 1)\n\n### a more thorough test on normality using the Kolmogrov-Smirnov tests\nebp_kstest &lt;- function(ebp_obj) {\n  \n  epsilon_values &lt;- residuals(ebp_obj$model, level = 0, type = \"pearson\") |&gt;\n    as.numeric()\n  mu_values &lt;- as.numeric(nlme::ranef(ebp_obj$model)$\"(Intercept)\")\n  \n  mu_values &lt;- (mu_values - mean(mu_values, na.rm = TRUE)) /\n    sd(mu_values, na.rm = TRUE)\n  \n  xx &lt;- ks.test(\n    x = epsilon_values,\n    y = \"pnorm\",\n    mean = mean(epsilon_values),\n    sd = sd(epsilon_values)\n  )\n  \n  yy &lt;- ks.test(\n    x = mu_values,\n    y = \"pnorm\",\n    mean = mean(mu_values),\n    sd = sd(mu_values)\n  )\n  \n  plot_random &lt;-\n    mu_values %&gt;%\n    as.data.table() %&gt;%\n    setnames(new = \"values\") %&gt;%\n    ggplot() +\n    geom_density(aes(x = values), fill = \"blue\", alpha = 0.5) +\n    labs(\n      x = \"Random Effects\", \n      y = \"Density\", \n      title = \"Random Effect Residuals (\\u03BC)\"\n    ) +\n    theme_minimal() +\n    ylim(0, 0.4) +\n    xlim(-4, 4) +\n    annotate(\n      \"richtext\",\n      x = 0,\n      y = 0.3,\n      label = \"&lt;b&gt;Kolmogrov-Smirnov Normality Test&lt;/b&gt;\",\n      fill = NA,\n      label.color = NA\n    ) +\n    annotate(\n      \"text\",\n      x = 0,\n      y = 0.28,\n      label =\n        paste0(\n          \"D-stat = \",\n          specify_decimal(yy$statistic, 3),\n          \"; p-value = \",\n          specify_decimal(yy$p.value, 3)\n        ),\n      size = 3\n    )\n  \n  plot_error &lt;-\n    epsilon_values %&gt;%\n    as.data.table() %&gt;%\n    setnames(new = \"values\") %&gt;%\n    ggplot() +\n    geom_density(aes(x = values), fill = \"blue\", alpha = 0.5) +\n    labs(x = \"Model Error Terms\",\n         y = \"Density\", \n         title = \"Standardized Error Residuals (\\u03B5)\") +\n    theme_minimal() +\n    annotate(\n      \"richtext\",\n      x = 0.75,\n      y = 0.3,\n      label = \"&lt;b&gt;Kolmogrov-Smirnov Normality Test&lt;/b&gt;\",\n      fill = NA,\n      label.color = NA\n    ) +\n    annotate(\n      \"text\",\n      x = 0,\n      y = 0.28,\n      label = paste0(\n        \"D-stat = \",\n        specify_decimal(xx$statistic, 3),\n        \"; p-value = \",\n        specify_decimal(xx$p.value, 3)\n      ),\n      size = 3\n    )\n  \n  plot_random + plot_error\n}\n\nebp_kstest(log_model)\n\n\n\n\n\n\n\n\n\n\n\n3.5.2 CV Estimation\n\n### it is important to compare Coefficient of Variation between the survey direct estimates and the census computations. \n\n#### first using the povmap::direct() function to estimate the direct and model estimate cvs for the poverty rates\n\nebp_compare_cv &lt;- function(ebp_obj, ...) {\n  \n  # Convert to data.table\n  ind_dt &lt;- as.data.table(ebp_obj$ind)\n  mse_dt &lt;- as.data.table(ebp_obj$MSE)\n\n  # Ensure mse_dt and ind_dt are numeric except Domain\n  mse_numeric &lt;- mse_dt[, !(\"Domain\"), with = FALSE]\n  ind_numeric &lt;- ind_dt[, !(\"Domain\"), with = FALSE]\n\n  # Compute CV\n  ebpcv_dt &lt;- sqrt(mse_numeric) / ind_numeric\n\n  # Add Domain back\n  ebpcv_dt[, Domain := ind_dt$Domain]\n\n  # Compute direct estimation\n  direct_dt &lt;- povmap::direct(...)\n\n  # Identify numeric columns common to both\n  common_cols &lt;- intersect(names(direct_dt$ind), names(direct_dt$MSE))\n  numeric_cols &lt;- common_cols[sapply(as.data.table(direct_dt$ind)[, ..common_cols], is.numeric)]\n\n  # Compute CV for direct estimation\n  directcv_dt &lt;- sqrt(as.data.table(direct_dt$MSE)[, ..numeric_cols]) / \n                 as.data.table(direct_dt$ind)[, ..numeric_cols]\n\n  # Add Domain back and rename\n  directcv_dt &lt;- \n    cbind(as.data.table(direct_dt$ind)[, .(Domain)], directcv_dt) %&gt;%\n          dplyr::select(Domain, Head_Count) %&gt;%\n          rename(HT_Head_Count = Head_Count)\n\n  # Merge direct and EBP results\n  cv_dt &lt;- directcv_dt[ebpcv_dt, on = \"Domain\"]\n\n  # Rename columns for clarity\n  setnames(cv_dt, \"Head_Count\", \"Head_Count_CV\")\n  setnames(cv_dt, \"HT_Head_Count\", \"HT_Head_Count_CV\")\n\n  return(cv_dt)\n  \n}\n\n\ncv_dt &lt;- ebp_compare_cv(ebp_obj = log_model,\n                        y = \"eqIncome\",\n                        smp_data = survey_dt,\n                        smp_domains = \"district\",\n                        weights = \"weight\",\n                        var = TRUE,\n                        threshold = 18207.2,\n                        design = \"state\",\n                        na.rm = TRUE,\n                        HT = TRUE)\n\n\n### it is useful to be able to be able to figure out how \ngains_value &lt;- \n  cv_dt |&gt;\n  mutate(gains = HT_Head_Count_CV / Head_Count_CV) |&gt;\n  summarize(mean(gains, na.rm = TRUE))\n\n#### create visualization to show how the EBP CVs are an improvement on the Horwitz-Thompson Headcount CVs\n#### as a result of SAE\n\ncv_dt |&gt;\n  ggplot() + \n  geom_point(aes(y = Head_Count_CV, x = HT_Head_Count_CV)) + \n  geom_abline(slope = 1, intercept = 0, linetype = \"dashed\", color = \"blue\") + \n  labs(x = \"Horwitz-Thompson Headcount CV\",\n       y = \"EBP Head Count CV\") + \n  xlim(0, 1.5) + \n  ylim(0, 1.5) + \n  scale_color_viridis_d(option = \"plasma\") + \n  theme_minimal()\n\nWarning: Removed 26 rows containing missing values or values outside the scale range\n(`geom_point()`).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unit-Level Models</span>"
    ]
  },
  {
    "objectID": "ul.html#poverty-map",
    "href": "ul.html#poverty-map",
    "title": "3  Unit-Level Models",
    "section": "3.6 Poverty map",
    "text": "3.6 Poverty map\n\n### plot the poverty map\n\n#### load the shapefile from the povmap\npovmap::load_shapeaustria()\n\nlog_model$ind[c(\"Domain\", \"Head_Count\")] |&gt;\n  merge(shape_austria_dis[, c(\"PB\")],\n        by.x = \"Domain\", by.y = \"PB\") |&gt;\n  sf::st_as_sf(crs = 4326) |&gt;\n  ggplot() + \n  geom_sf(aes(fill = Head_Count)) + \n  scale_fill_viridis_c(option = \"magma\",\n                       direction = -1,\n                       name = \"Poverty Rate\") + \n  labs(title = \"Poverty Map: Austria\") + \n  theme_minimal() + \n  theme(axis.title = element_blank(), # Remove axis labels\n        axis.text = element_blank(),  # Remove axis text\n        panel.grid = element_blank(), # Remove grid lines\n        plot.title = element_text(hjust = 0.5, size = 16), # Center and style title\n        plot.subtitle = element_text(hjust = 0.5, size = 12))\n\n\n\n\n\n\n\nFigure 3.3\n\n\n\n\n\n\n\n\n\n\n\nCorral, Paul, Isabel Molina, Alexandru Cojocaru, and Sandra Segovia. 2022. Guidelines to Small Area Estimation for Poverty Mapping. World Bank Washington.\n\n\nKreutzmann, Ann-Kristin, Sören Pannier, Natalia Rojas-Perilla, Timo Schmid, Matthias Templ, and Nikos Tzavidis. 2019. “The r Package Emdi for Estimating and Mapping Regionally Disaggregated Indicators.” Journal of Statistical Software 91: 1–33.\n\n\nMolina, Isabel, and Jon NK Rao. 2010. “Small Area Estimation of Poverty Indicators.” Canadian Journal of Statistics 38 (3): 369–85.\n\n\nRao, John NK, and Isabel Molina. 2015. Small Area Estimation. John Wiley & Sons.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unit-Level Models</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Corral, Paul, Isabel Molina, Alexandru Cojocaru, and Sandra Segovia.\n2022a. Guidelines to Small Area Estimation for Poverty Mapping.\nWorld Bank Washington.\n\n\n———. 2022b. Guidelines to Small Area Estimation for Poverty\nMapping. World Bank Washington.\n\n\nKreutzmann, Ann-Kristin, Sören Pannier, Natalia Rojas-Perilla, Timo\nSchmid, Matthias Templ, and Nikos Tzavidis. 2019. “The r Package\nEmdi for Estimating and Mapping Regionally Disaggregated\nIndicators.” Journal of Statistical Software 91: 1–33.\n\n\nMolina, Isabel, and Jon NK Rao. 2010. “Small Area Estimation of\nPoverty Indicators.” Canadian Journal of Statistics 38\n(3): 369–85.\n\n\nRao, John NK, and Isabel Molina. 2015. Small Area Estimation.\nJohn Wiley & Sons.",
    "crumbs": [
      "References"
    ]
  }
]